<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="jdIa3b5GkY" />
  
  <title>hash表与bloom filter | Tyrone Li的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="如果想要快速存取一串小整数，可以用一个数组来存储。将整数的值作为它们在数组中的索引位置，这样就可以在O(1)的时间内快速访问任何一个整数。在日常开发中，我们常常会遇到更加复杂的问题：判断某个对象是否存在于某个集合中。例如在字处理时，判断字是否拼写正确（也就是判断它是否在已知的字典中）；在网络爬虫中，判断某个URL是否被访问过等等。在计算机中，我们通常用hash表来处理这一类问题。hash表是前面所">
<meta property="og:type" content="article">
<meta property="og:title" content="hash表与bloom filter">
<meta property="og:url" content="http://ningquec.github.io/2015/06/13/HashTable&BloomFilter/index.html">
<meta property="og:site_name" content="Tyrone Li的博客">
<meta property="og:description" content="如果想要快速存取一串小整数，可以用一个数组来存储。将整数的值作为它们在数组中的索引位置，这样就可以在O(1)的时间内快速访问任何一个整数。在日常开发中，我们常常会遇到更加复杂的问题：判断某个对象是否存在于某个集合中。例如在字处理时，判断字是否拼写正确（也就是判断它是否在已知的字典中）；在网络爬虫中，判断某个URL是否被访问过等等。在计算机中，我们通常用hash表来处理这一类问题。hash表是前面所">
<meta property="og:image" content="http://7xjnnt.com1.z0.glb.clouddn.com/IMG_20150613_173847.JPG">
<meta property="og:image" content="http://7xjnnt.com1.z0.glb.clouddn.com/6368753e-12ad-39ac-a72e-06981c316425.png">
<meta property="og:image" content="http://7xjnnt.com1.z0.glb.clouddn.com/图片1.png">
<meta property="og:image" content="http://7xjnnt.com1.z0.glb.clouddn.com/1590333618416425145.jpg">
<meta property="og:updated_time" content="2015-07-12T03:16:02.239Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hash表与bloom filter">
<meta name="twitter:description" content="如果想要快速存取一串小整数，可以用一个数组来存储。将整数的值作为它们在数组中的索引位置，这样就可以在O(1)的时间内快速访问任何一个整数。在日常开发中，我们常常会遇到更加复杂的问题：判断某个对象是否存在于某个集合中。例如在字处理时，判断字是否拼写正确（也就是判断它是否在已知的字典中）；在网络爬虫中，判断某个URL是否被访问过等等。在计算机中，我们通常用hash表来处理这一类问题。hash表是前面所">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="http://7xjnnt.com1.z0.glb.clouddn.com/tyrone博客头像.png" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Tyrone</a></h1>
		</hgroup>

		
		<p class="header-subtitle">天天向上</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/ningquec" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/树/" style="font-size: 15px;">树</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/集合类/" style="font-size: 10px;">集合类</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">天天向上</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Tyrone</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xjnnt.com1.z0.glb.clouddn.com/tyrone博客头像.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Tyrone</h1>
			</hgroup>
			
			<p class="header-subtitle">天天向上</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/ningquec" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-HashTable&amp;BloomFilter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/13/HashTable&BloomFilter/" class="article-date">
  	<time datetime="2015-06-13T06:02:43.000Z" itemprop="datePublished">2015-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      hash表与bloom filter
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果想要快速存取一串小整数，可以用一个数组来存储。将整数的值作为它们在数组中的索引位置，这样就可以在O(1)的时间内快速访问任何一个整数。<br>在日常开发中，我们常常会遇到更加复杂的问题：判断某个对象是否存在于某个集合中。例如在字处理时，判断字是否拼写正确（也就是判断它是否在已知的字典中）；在网络爬虫中，判断某个URL是否被访问过等等。在计算机中，我们通常用hash表来处理这一类问题。<br>hash表是前面所述数组的扩展，通过一系列算术操作（伪随机性函数）将对象转换为数组的索引位置，据此来实现在O(1)时间访问数组中的对象。</p>
<h2 id="一、hash函数的选择">一、hash函数的选择</h2><p>(1)hash函数的目的是将对象转换为数组的索引。如何选择好的hash函数呢？有一条最重要的规则：<code>保证均匀性</code>。<br>即一个好的hash函数要能够将对象均匀的映射到数组中，保证均匀性的最好方法也许就是保证对象的每一位都参与hash值的运算。<br>这段程序是String类型hash值计算的简单实现，Java中的String类型默认使用了近似的方法。<br>可以看到，程序中将str的每一位都参与到hash值的运算中。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hash = <span class="number">0</span>；</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">		hash = (R * hash + s.charAt(i)) % M</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在下图中，选择了这种String类型的hashcode()方法，将《双城记》中10679个单词大致均匀地分布到97个位置上。</p>
<p><img src="http://7xjnnt.com1.z0.glb.clouddn.com/IMG_20150613_173847.JPG" alt="双城记hash图"><br>Java针对每一种数据类型都继承了一个能返回32位整数的hashcode()方法，可以直接调用来完成对象到值的映射。<br>因为我们需要的是数组的索引而不是32位的整数，所以在实现中会将默认的hashcode()方法同取余结合起来产生一个0到M-1的整数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将hashcode()返回值转化为M长度的数组索引</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x.hashcode() &amp; <span class="number">0x7fffffff</span>) % M    </span><br><span class="line">	<span class="comment">//先令hashcode()的结果同0x7fffffff相与，将32位整数转换为31位的非负整数（屏蔽符号位）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Java中自定义的对象，你可以试着自己重写hashcode()方法。但要记住一点：同时重写hashcode()方法和equals()方法。<br>因为默认情况下，<code>每一种数据类型的hashcode()方法都必须和equals()方法保持一致。</code>如果a.equals(b)返回true，那么a.hashcode()的返回值必然和b.hashcode()的返回值相同。<br>相反，如果两个对象的hashcode()方法返回值不同，那么我们知道这两个对象是不同的。但如果两个对象的hashcode()方法返回值相同，这两个对象也可能不同，我们需要继续通过equals()方法来判断。</p>
<h2 id="二、处理碰撞问题">二、处理碰撞问题</h2><p>hash算法的第二步是<code>碰撞处理</code>。当两个不同的对象经过hash函数处理之后，可能会得出相同hash值。<br>一种直接的方法是将大小为M的数组中的每个元素指向一个链表，同一个链表中的节点存储hash值相同的对象。如图。为了保证均匀性，M条链表存储N个节点时候，要保证链表的平均长度约为N/M。<br>Java中的集合类<a href="http://tyroneli.com/2015/07/11/CollectionHashMap/" target="_blank" rel="external">HashMap</a>，HashTable和ConcurrentHashMap均采用了这种方法。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/6368753e-12ad-39ac-a72e-06981c316425.png" alt="拉链法图示"><br>解决碰撞问题的另外一种方式就是用大小M的数组保存N个对象，其中M&gt;N，利用数组中的空白位置来解决碰撞。<br>当碰撞发生的时候，我们直接检查数组下一个为空的位置，将其作为对象的索引位置。这样的方法叫做线性探测法。</p>
<h2 id="三、hash表的效率问题探究">三、hash表的效率问题探究</h2><p>hash表的平均时间复杂度是O(1)，这是它的优点之一，这里主要讨论hash表所需的空间大小。假设有一个大小为M的使用线性探测法的散列表，其中N个位置存储了对象(M&gt;N)。命中和未命中的查找所需的探测次数分别为：（这个公式我想了很久，可是没有证明出来，求大神指导）<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/图片1.png"><br>由公式可知，当装载因子a=N/M趋近于1的时候，探测次数大大增加，精确度严重下降，不能保证在O(1)的时间内完成存取。同时要兼顾hash表存储空间的利用效率，<code>一般保证其装载因子在1/2左右</code>，探测的预计次数在1.5到2.5之间。</p>
<h2 id="四、bloom_filter的原理">四、bloom filter的原理</h2><p>hash表的存储效率一般只有50%，那么在大数据量环境下想要快速判断对象是否在集合中就显得不太合适了。<br>比如在过滤垃圾邮件时，一种方法就是用hash表记录下那些垃圾邮件的地址，然后判断那些邮件发件人地址是否在表内。由于发送者不断注册新的地址，全球少说也有几十亿的地址。<br>假设采用8个字节来标记一个地址，一亿个地址需要0.8GB来存储，放在散列表中就需要1.6GB。因此，一般的服务器不可能存储几十亿个地址。<br>1970年，Burton Bloom提出了一种叫bloom filter的数学工具，它在执行hash表职责的同时仅仅需要hash表1/8到1/4的大小。bloom filter实际上是一个很长的二进制向量和一系列随机映射函数，下面说明它的工作原理。<br>假定要存储一亿个垃圾邮件地址的黑名单，先建立一个16亿个比特位即两亿字节的向量，然后将这16亿个比特位全部清零。对于每一个电子邮件地址X，用8个不同的随机数产生器(F1,F2,F3,F4,F5,F6,F7,F8)产生8个信息指纹(f1,f2,f3,f4,f5,f6,f7,f8)。<br>再用一个随机数产生器G把这8个信息指纹映射到1——16亿中的8个位置。现在把这8个位置的比特位全部置为1。对这一亿个垃圾邮件地址都进行这样的处理之后（如果某一位已经是1，保持不变），一个针对这些电子邮件地址的bloom filter就建成了，见下图。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/1590333618416425145.jpg" alt="bloom filter图示"><br>现在就可以利用bloom filter来检测一个可疑的电子邮件地址Y是否在黑名单中。用同样的8个随机数产生器(F1,F2,F3,F4,F5,F6,F7,F8)产生8个信息指纹(f1,f2,f3,f4,f5,f6,f7,f8)，然后将这8个指纹映射到8个比特位上。<br>如果Y在黑名单中，那么这8位一定是1。<code>bloom filter不会漏掉黑名单中任何一个可以地址，但是它也可能产生误判。</code><br>想像这样一个场景：一个正常的地址经过8个的随机数产生器，映射的8个位置上正好全被其它垃圾邮件置为1，按照规则正常的地址也被过滤掉了。<br>所幸这样的概率很低，在上面的例子中，误识别率在万分之一以下。我们可以建立一个小的白名单来存储那些容易误判的地址。</p>
<h2 id="五、大数据环境下bloom_filter的应用">五、大数据环境下bloom filter的应用</h2><p>在我今年4月份找实习的过程中，BAT都非常喜欢问海量数据问题，bloom filter是其中一个很常用的方法。<br>【例子】给定a、b两个文件，各存放20亿个URL，每个URL各占64个字节，内存限制是4G，请找出共同的URL。<br>在回答这道题之前，最好向面试官询问是否允许一定的误识别率，然后决定是否使用bloom filter。4G内存大约可以表示340亿比特位，将其中一个文件中的20亿URL映射为160亿比特位（装载因子大概在0.48左右），然后遍历另一个文件，判断每一个URL映射的比特位是否都已经被置为1。</p>
<h2 id="六、参考书籍">六、参考书籍</h2><p>（1）数学之美。吴军著<br>（2）算法。Robert Sedgewick,Kevin Wayne著，谢路云译</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/06/16/CommandGrep/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          grep 命令详解
        
      </div>
    </a>
  
  
    <a href="/2015/06/11/CommandFind/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">find命令拾遗</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="HashTable&amp;BloomFilter" data-title="hash表与bloom filter" data-url="http://ningquec.github.io/2015/06/13/HashTable&amp;BloomFilter/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>



</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Tyrone
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>