<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Tyrone Li的博客]]></title>
  <subtitle><![CDATA[天天向上]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ningquec.github.io//"/>
  <updated>2016-02-14T12:14:58.665Z</updated>
  <id>http://ningquec.github.io//</id>
  
  <author>
    <name><![CDATA[Tyrone]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用OpenCV开发简单的OCR系统]]></title>
    <link href="http://ningquec.github.io/2016/02/14/BasicOCRInOpenCV/"/>
    <id>http://ningquec.github.io/2016/02/14/BasicOCRInOpenCV/</id>
    <published>2016-02-14T08:29:14.000Z</published>
    <updated>2016-02-14T12:14:58.665Z</updated>
    <content type="html"><![CDATA[<h1 id="一、简介">一、简介</h1><p>OCR（光学字符识别）是现在比较成熟的技术，是指电子设备（例如扫描仪或数码相机）检查纸（或者器具）上打印的字符通过检测暗、亮的模式确定其形状。然后用字符识别方法将形状翻译成计算机文字的过程：即对文本资料进行扫描，然后对图像文件进行分析处理、获取文字及版面信息的过程。<br>现在市面上的产品主要有小猿搜题、学习宝、CAJajViewer等，识别率能达到<a href="https://www.zhihu.com/topic/19574441/top-answers" target="_blank" rel="external">较高水平</a>。原理一般都是卷积神经网络等机器学习方法，结合多种图像处理技术。<br>本篇文章主要译自<a href="http://blog.damiles.com/2008/11/basic-ocr-in-opencv/" target="_blank" rel="external">DAMILES的博客</a>，其中采用<a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" target="_blank" rel="external">KNN（K-Nearest Neighbor）算法</a>来识别手写数字，识别率肯定大大不如卷积神经网络，旨在介绍OpenCV中machine learning模块的简单应用。<br><a id="more"></a></p>
<h1 id="二、正文">二、正文</h1><p>在这篇教程中，我们将要创建一个基本的数字OCR，它能将手写数字分类识别出来。</p>
<p>为了完成这个OCR，我们需要用到前面一些教程的知识，包括<a href="http://blog.damiles.com/2008/11/basic-painter-in-opencv/" target="_blank" rel="external">basic painter</a>和<a href="http://blog.damiles.com/2008/11/the-basic-patter-recognition-and-classification-with-opencv/" target="_blank" rel="external">the basic pattern recognition and classification with openCV</a>教程。</p>
<p>一个典型的模式识别分类器由3部分组成：<br><img src="" alt="模式识别分类器"><br>Preprocessing（预处理）：我们在这个模块中处理输入的图像，比如尺寸归一化、转换颜色空间等；<br>Feature extraction（特征提取）：在这个模块中，我们将图像处理为一个用于分类的特征向量，向量可以由像素矩阵拉伸而成，也可以用图像轮廓的链码数据表示。<br>Classification（分类）：在这个模块中有两个功能。其一，用获取的特征向量集训练模型；其二，用训练好的模型去分类输入的特征向量。训练方法采用KNN。</p>
<p>这个基本的OCR流程图如下：<br><img src="" alt="OCR流程图"><br>从哪里获取训练和测试数字图像用于训练和测试分类器模型（KNN）：<br>我们有1000张手写数字图像，每个数字有100张。从每个数字的100张中选取50张作为训练集，其它用作测试集。<br><img src="" alt="手写数字"></p>
<p>接下来的第一件事就是对所有的训练集进行预处理，我们会创建一个预处理函数。这个函数的输入参数为手写数字图像、处理结果图像的width和height，返回值为归一化尺寸且包含边界框的手写数字图像，下图更清楚的显示了预处理过程：<br><img src="" alt="预处理图示"></p>
<p>预处理代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findX</span><span class="params">(IplImage* imgSrc,<span class="keyword">int</span>* min, <span class="keyword">int</span>* max)</span></span>&#123;</span><br><span class="line">	<span class="comment">//找到X方向上的边界</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> minFound=<span class="number">0</span>;</span><br><span class="line">	CvMat data;</span><br><span class="line">	CvScalar maxVal=cvRealScalar(imgSrc-&gt;width * <span class="number">255</span>);</span><br><span class="line">	CvScalar val=cvRealScalar(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; imgSrc-&gt;width; i++)&#123;</span><br><span class="line">		cvGetCol(imgSrc, &amp;data, i);</span><br><span class="line">		val= cvSum(&amp;data);</span><br><span class="line">		<span class="keyword">if</span>(val.val[<span class="number">0</span>] &lt; maxVal.val[<span class="number">0</span>])&#123;</span><br><span class="line">			*max= i;</span><br><span class="line">			<span class="keyword">if</span>(!minFound)&#123;</span><br><span class="line">				*min= i;</span><br><span class="line">				minFound= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findY</span><span class="params">(IplImage* imgSrc,<span class="keyword">int</span>* min, <span class="keyword">int</span>* max)</span></span>&#123;</span><br><span class="line">	<span class="comment">//找到Y方向上的边界</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> minFound=<span class="number">0</span>;</span><br><span class="line">	CvMat data;</span><br><span class="line">	CvScalar maxVal=cvRealScalar(imgSrc-&gt;width * <span class="number">255</span>);</span><br><span class="line">	CvScalar val=cvRealScalar(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//For each col sum, if sum &lt; width*255 then we find the min</span></span><br><span class="line">	<span class="comment">//then continue to end to search the max, if sum&lt; width*255 then is new max</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; imgSrc-&gt;height; i++)&#123;</span><br><span class="line">		cvGetRow(imgSrc, &amp;data, i);</span><br><span class="line">		val= cvSum(&amp;data);</span><br><span class="line">		<span class="keyword">if</span>(val.val[<span class="number">0</span>] &lt; maxVal.val[<span class="number">0</span>])&#123;</span><br><span class="line">			*max=i;</span><br><span class="line">			<span class="keyword">if</span>(!minFound)&#123;</span><br><span class="line">				*min= i;</span><br><span class="line">				minFound= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CvRect <span class="title">findBB</span><span class="params">(IplImage* imgSrc)</span></span>&#123;</span><br><span class="line">	<span class="comment">//获得数字的边界框</span></span><br><span class="line">	CvRect aux;</span><br><span class="line">	<span class="keyword">int</span> xmin, xmax, ymin, ymax;</span><br><span class="line">	xmin=xmax=ymin=ymax=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	findX(imgSrc, &amp;xmin, &amp;xmax);</span><br><span class="line">	findY(imgSrc, &amp;ymin, &amp;ymax);</span><br><span class="line"></span><br><span class="line">	aux=cvRect(xmin, ymin, xmax-xmin, ymax-ymin);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IplImage <span class="title">preprocessing</span><span class="params">(IplImage* imgSrc,<span class="keyword">int</span> new_width, <span class="keyword">int</span> new_height)</span></span>&#123;</span><br><span class="line">	IplImage* result;</span><br><span class="line">	IplImage* scaledResult;</span><br><span class="line"></span><br><span class="line">	CvMat data;</span><br><span class="line">	CvMat dataA;</span><br><span class="line">	CvRect bb;         <span class="comment">//边界框</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//找到边界框</span></span><br><span class="line">	bb=findBB(imgSrc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在图像中获取边界框区域</span></span><br><span class="line">	cvGetSubRect(imgSrc, &amp;data, cvRect(bb.x, bb.y, bb.width, bb.height));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将边界框的边长设为height和width中的较大值，转变为正方形</span></span><br><span class="line">	<span class="keyword">int</span> size=(bb.width&gt;bb.height)?bb.width:bb.height;</span><br><span class="line">	result=cvCreateImage( cvSize( size, size ), <span class="number">8</span>, <span class="number">1</span> );</span><br><span class="line">	cvSet(result,CV_RGB(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),NULL);</span><br><span class="line">	<span class="comment">//Copy de data in center of image</span></span><br><span class="line">	<span class="keyword">int</span> x=(<span class="keyword">int</span>)<span class="built_in">floor</span>((<span class="keyword">float</span>)(size-bb.width)/<span class="number">2.0f</span>);</span><br><span class="line">	<span class="keyword">int</span> y=(<span class="keyword">int</span>)<span class="built_in">floor</span>((<span class="keyword">float</span>)(size-bb.height)/<span class="number">2.0f</span>);</span><br><span class="line">	cvGetSubRect(result, &amp;dataA, cvRect(x,y,bb.width, bb.height));</span><br><span class="line">	cvCopy(&amp;data, &amp;dataA, NULL);</span><br><span class="line">	<span class="comment">//Scale result</span></span><br><span class="line">	scaledResult=cvCreateImage( cvSize( new_width, new_height ), <span class="number">8</span>, <span class="number">1</span> );</span><br><span class="line">	cvResize(result, scaledResult, CV_INTER_NN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Return processed data</span></span><br><span class="line">	<span class="keyword">return</span> *scaledResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用basicOCR类中的函数getData来获取训练数据和数据的类别。getData函数会读取所有在OCR文件夹下的训练数据，该文件夹下为每一个数字（类别）创建了一个文件夹，每一个文件夹内存放训练用的pbm文件，文件名形如：cnn.pbm，c代表该数字（0-9），nn表示手写数字图像的编号（00-99）。</p>
<p>获取到的每一幅图像都要经过预处理，并且把图像数据转换为特征向量。</p>
<p>getData函数代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> basicOCR::getData()&#123;</span><br><span class="line">	IplImage* src_image;</span><br><span class="line">	IplImage prs_image;</span><br><span class="line">	CvMat row,data;</span><br><span class="line">	<span class="keyword">char</span> file[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i =<span class="number">0</span>; i &lt; classes; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>( j = <span class="number">0</span>; j&lt; train_samples; j++)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Load file</span></span><br><span class="line">		<span class="keyword">if</span>(j&lt;<span class="number">10</span>)</span><br><span class="line">			<span class="built_in">sprintf</span>(file,<span class="string">"%s%d/%d0%d.pbm"</span>,file_path, i, i , j);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">sprintf</span>(file,<span class="string">"%s%d/%d%d.pbm"</span>,file_path, i, i , j);</span><br><span class="line">		src_image = cvLoadImage(file,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(!src_image)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Error: Cant load image %s\n"</span>, file);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//process file</span></span><br><span class="line">		prs_image = preprocessing(src_image, size, size);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Set class label</span></span><br><span class="line">		cvGetRow(trainClasses, &amp;row, i*train_samples + j);</span><br><span class="line">		cvSet(&amp;row, cvRealScalar(i));</span><br><span class="line">		<span class="comment">//Set data</span></span><br><span class="line">		cvGetRow(trainData, &amp;row, i*train_samples + j);</span><br><span class="line"></span><br><span class="line">		IplImage* img = cvCreateImage( cvSize( size, size ), IPL_DEPTH_32F, <span class="number">1</span> );</span><br><span class="line">		<span class="comment">//convert 8 bits image to 32 float image</span></span><br><span class="line">		cvConvertScale(&amp;prs_image, img, <span class="number">0.0039215</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		cvGetSubRect(img, &amp;data, cvRect(<span class="number">0</span>,<span class="number">0</span>, size,size));</span><br><span class="line"></span><br><span class="line">		CvMat row_header, *row1;</span><br><span class="line">		<span class="comment">//convert data matrix sizexsize to vecor</span></span><br><span class="line">		row1 = cvReshape( &amp;data, &amp;row_header, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">		cvCopy(row1, &amp;row, NULL);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过获取数据并对其预处理之后，我们用这些处理过的数据训练模型，在这个例子中使用KNN算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">knn=<span class="keyword">new</span> CvKNearest( trainData, trainClasses, <span class="number">0</span>, <span class="keyword">false</span>, K );</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line">CvKNearest::CvKNearest(</span><br><span class="line">			CvMat* trainData, </span><br><span class="line">			<span class="keyword">const</span> CvMat* responses, </span><br><span class="line">			<span class="keyword">const</span> CvMat* sampleIdx=<span class="number">0</span>, </span><br><span class="line">			<span class="keyword">bool</span> isRegression=<span class="keyword">false</span>, </span><br><span class="line">			<span class="keyword">int</span> max_k=<span class="number">32</span> )</span><br></pre></td></tr></table></figure></p>
<p>接下来我们可以测试这个训练好的模型了，可以用测试的结果去和采用其他机器学习方法的结果比较，也可以比较更改训练图像的尺寸的结果。下面这个函数basicOCR::test()用来测试。这个函数获取剩下的500张测试图像，使用KNN将其分类，并查看返回的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> basicOCR::test()&#123;</span><br><span class="line">	IplImage* src_image;</span><br><span class="line">	IplImage prs_image;</span><br><span class="line">	CvMat row,data;</span><br><span class="line">	<span class="keyword">char</span> file[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> error=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> testCount=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i =<span class="number">0</span>; i &lt; classes; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>( j = <span class="number">50</span>; j&lt; <span class="number">50</span>+train_samples; j++)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">sprintf</span>(file,<span class="string">"%s%d/%d%d.pbm"</span>,file_path, i, i , j);</span><br><span class="line">			src_image = cvLoadImage(file,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(!src_image)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Error: Cant load image %s\n"</span>, file);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//process file</span></span><br><span class="line">			prs_image = preprocessing(src_image, size, size);</span><br><span class="line">			<span class="keyword">float</span> r=classify(&amp;prs_image,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>((<span class="keyword">int</span>)r!=i)</span><br><span class="line">			error++;</span><br><span class="line"></span><br><span class="line">			testCount++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">float</span> totalerror=<span class="number">100</span>*(<span class="keyword">float</span>)error/(<span class="keyword">float</span>)testCount;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"System Error: %.2f%%\n"</span>, totalerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test函数调用了classify函数来分类图像、处理图像、获取特征向量，以及将特征向量分入某个类别（KNN方法），代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> basicOCR::classify(IplImage* img, <span class="keyword">int</span> showResult)&#123;</span><br><span class="line">	IplImage prs_image;</span><br><span class="line">	CvMat data;</span><br><span class="line">	CvMat* nearest=cvCreateMat(<span class="number">1</span>,K,CV_32FC1);</span><br><span class="line">	<span class="keyword">float</span> result;</span><br><span class="line">	<span class="comment">//process file</span></span><br><span class="line">	prs_image = preprocessing(img, size, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set data</span></span><br><span class="line">	IplImage* img32 = cvCreateImage( cvSize( size, size ), IPL_DEPTH_32F, <span class="number">1</span> );</span><br><span class="line">	cvConvertScale(&amp;prs_image, img32, <span class="number">0.0039215</span>, <span class="number">0</span>);</span><br><span class="line">	cvGetSubRect(img32, &amp;data, cvRect(<span class="number">0</span>,<span class="number">0</span>, size,size));</span><br><span class="line">	CvMat row_header, *row1;</span><br><span class="line">	row1 = cvReshape( &amp;data, &amp;row_header, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">	result=knn-&gt;find_nearest(row1,K,<span class="number">0</span>,<span class="number">0</span>,nearest,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> accuracy=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>( nearest-&gt;data.fl[i] == result)</span><br><span class="line">			accuracy++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">float</span> pre=<span class="number">100</span>*((<span class="keyword">float</span>)accuracy/(<span class="keyword">float</span>)K);</span><br><span class="line">	<span class="keyword">if</span>(showResult==<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"|\t%.0f\t| \t%.2f%%&amp;nbsp; \t| \t%d of %d \t| \n"</span>,result,pre,accuracy,K);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" ---------------------------------------------------------------\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有的训练和测试工作都在basicOCR类中进行。创建了basicOCR实例之后，仅需要调用classify函数去分类我们的输入手写数字图像即可。现在我们可以用之前教程<a href="http://blog.damiles.com/2008/11/basic-painter-in-opencv/" target="_blank" rel="external">basic painter</a>去画一个数字图像并且把它分类。<br>项目地址：<a href="https://github.com/damiles/basicOCR" target="_blank" rel="external">托管在github</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、简介">一、简介</h1><p>OCR（光学字符识别）是现在比较成熟的技术，是指电子设备（例如扫描仪或数码相机）检查纸（或者器具）上打印的字符通过检测暗、亮的模式确定其形状。然后用字符识别方法将形状翻译成计算机文字的过程：即对文本资料进行扫描，然后对图像文件进行分析处理、获取文字及版面信息的过程。<br>现在市面上的产品主要有小猿搜题、学习宝、CAJajViewer等，识别率能达到<a href="https://www.zhihu.com/topic/19574441/top-answers">较高水平</a>。原理一般都是卷积神经网络等机器学习方法，结合多种图像处理技术。<br>本篇文章主要译自<a href="http://blog.damiles.com/2008/11/basic-ocr-in-opencv/">DAMILES的博客</a>，其中采用<a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">KNN（K-Nearest Neighbor）算法</a>来识别手写数字，识别率肯定大大不如卷积神经网络，旨在介绍OpenCV中machine learning模块的简单应用。<br>]]>
    
    </summary>
    
      <category term="C" scheme="http://ningquec.github.io/tags/C/"/>
    
      <category term="OCR" scheme="http://ningquec.github.io/tags/OCR/"/>
    
      <category term="OpenCV" scheme="http://ningquec.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习OpenCV：寻找图像中的Data Matrix区域（2）]]></title>
    <link href="http://ningquec.github.io/2016/01/30/OpenCVfindDataMatrix2/"/>
    <id>http://ningquec.github.io/2016/01/30/OpenCVfindDataMatrix2/</id>
    <published>2016-01-30T09:51:26.000Z</published>
    <updated>2016-02-14T04:04:36.064Z</updated>
    <content type="html"><![CDATA[<h1 id="一、简介">一、简介</h1><p><a href="http://tyroneli.com/2016/01/19/OpenCVfindDataMatrix/" target="_blank" rel="external">上篇</a>中简单介绍了膨胀腐蚀两种基本的形态学操作，这两种操作可以很好的对二值化图像起作用。然而，在处理灰度或者彩色图像时，往往需要更加通用的形态学操作。下面这五种操作都基于膨胀腐蚀进行。</p>
<table><tr><th>操作名称</th><th>形态学操作</th><th>是否需要临时图像</th></tr><tr><td>CV_MOP_OPEN</td><td>开运算</td><td>否</td></tr><tr><td>CV_MOP_CLOSE</td><td>闭运算</td><td>否</td></tr><tr><td>CV_MOP_GRADIENT</td><td>形态学梯度</td><td>是</td></tr><tr><td>CV_MOP_TOPHAT</td><td>礼帽</td><td>原地操作需要</td></tr><tr><td>CV_MOP_BLACKHAT</td><td>黑帽</td><td>原地操作需要</td></tr></table>

<p>操作函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形态学操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvMorphologyEx</span><span class="params">(</span><br><span class="line">					<span class="keyword">const</span> CvArr* src,            //原图像</span><br><span class="line">					CvArr* dst,                  //目标图像</span><br><span class="line">					CvArr* temp,                 //临时图像</span><br><span class="line">					IplConvKernel* element,      //形态学操作卷积核</span><br><span class="line">					<span class="keyword">int</span> operation,               //指定形态学操作</span><br><span class="line">					<span class="keyword">int</span> iterations CV_DEFAULT(1)</span>)</span>;   <span class="comment">//迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置卷积核</span></span><br><span class="line">IplConvKernel* cvCreateStructuringElementEx(</span><br><span class="line">					<span class="keyword">int</span> cols,              </span><br><span class="line">					<span class="keyword">int</span> rows,           <span class="comment">//设置核尺寸为cols*rows</span></span><br><span class="line">					<span class="keyword">int</span> anchor_x,      </span><br><span class="line">					<span class="keyword">int</span> anchor_y,       <span class="comment">//设置核的锚点位置</span></span><br><span class="line">					<span class="keyword">int</span> shape,          <span class="comment">//设置核的形状，一般为矩形</span></span><br><span class="line">					<span class="keyword">int</span>* <span class="function">values <span class="title">CV_DEFAULT</span><span class="params">(NULL)</span>)</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="二、形态学操作">二、形态学操作</h1><h3 id="1-_开闭运算">1. 开闭运算</h3><p>开运算：先腐蚀后膨胀；<br>闭运算：先膨胀后腐蚀。</p>
<p>这两种运算和膨胀腐蚀的结果类似，但是开闭运算能更精确地保存原图像连接的区域。开运算去除小的明亮区域，并且剩余的明亮区域被隔绝，但其大小不变。闭运算能够消除低亮度的孤立点。<br>在Data Matrix码中，存在有大量小的明亮区域（深浅色点交替产生），所以开运算能有效的将疑似Data Matrix区域连接起来，并且大小不变。</p>
<h3 id="2-_形态学梯度（有别于计算梯度）">2. 形态学梯度（有别于计算梯度）</h3><p>形态学梯度 = 膨胀图像 - 腐蚀图像，进行这一操作能将边缘显示出来。</p>
<h3 id="3-_礼帽黑帽">3. 礼帽黑帽</h3><p>礼帽 = 原图像 - 开运算图像；<br>黑帽 = 闭运算图像 - 原图。</p>
<h1 id="三、程序和运行结果">三、程序和运行结果</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cv.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;highgui.h&gt;</span></span><br><span class="line"></span><br><span class="line">IplImage* src;</span><br><span class="line">IplImage* gray;</span><br><span class="line">IplImage* binary;</span><br><span class="line">IplImage* it;</span><br><span class="line">IplImage* morphologyOpen;</span><br><span class="line">IplImage* morphologyClose;</span><br><span class="line">IplImage* morphologyGradient;</span><br><span class="line">IplImage* morphologyTophat;</span><br><span class="line">IplImage* morphologyBlackhat;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryImage</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morphlogy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	src = cvLoadImage(<span class="string">"F:\\opencv_pic\\datamatrix1.jpg"</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Can't load the data matrix image!"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cvNamedWindow(<span class="string">"src"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	gray = cvCreateImage(CvSize(src-&gt;width, src-&gt;height), src-&gt;depth, <span class="number">1</span>);</span><br><span class="line">	cvCvtColor(src, gray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">	binaryImage();</span><br><span class="line">	morphlogy();</span><br><span class="line">	cvWaitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morphlogy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置核的大小</span></span><br><span class="line">	IplConvKernel* kernel = cvCreateStructuringElementEx(<span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, CV_SHAPE_RECT);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//临时图像</span></span><br><span class="line">	IplImage* temp = cvCreateImage(cvGetSize(it), it-&gt;depth, it-&gt;nChannels);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *开运算</span><br><span class="line">	 *不需要临时图像</span><br><span class="line">	 */</span></span><br><span class="line">	morphologyOpen = cvCreateImage(cvGetSize(it), it-&gt;depth, it-&gt;nChannels);</span><br><span class="line">	cvMorphologyEx(it, morphologyOpen, NULL, kernel, CV_MOP_OPEN, <span class="number">1</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"morphologyOpen"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"morphologyOpen"</span>, morphologyOpen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *闭运算</span><br><span class="line">	 *不需要临时图像</span><br><span class="line">	 */</span></span><br><span class="line">	morphologyClose = cvCreateImage(cvGetSize(it), it-&gt;depth, it-&gt;nChannels);</span><br><span class="line">	cvMorphologyEx(it, morphologyClose, NULL, kernel, CV_MOP_CLOSE, <span class="number">1</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"morphologyClose"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"morphologyClose"</span>, morphologyClose);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *形态学梯度</span><br><span class="line">	 *需要临时图像</span><br><span class="line">	 */</span></span><br><span class="line">	morphologyGradient = cvCreateImage(cvGetSize(it), it-&gt;depth, it-&gt;nChannels);</span><br><span class="line">	cvMorphologyEx(it, morphologyGradient, temp, kernel, CV_MOP_GRADIENT, <span class="number">1</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"morphologyGradient"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"morphologyGradient"</span>, morphologyGradient);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *礼帽</span><br><span class="line">	 *非原地，不需要临时图像</span><br><span class="line">	 */</span></span><br><span class="line">	morphologyTophat = cvCreateImage(cvGetSize(it), it-&gt;depth, it-&gt;nChannels);</span><br><span class="line">	cvMorphologyEx(it, morphologyTophat, NULL, kernel, CV_MOP_TOPHAT, <span class="number">1</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"morphologyTophat"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"morphologyTophat"</span>, morphologyTophat);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 *黑帽</span><br><span class="line">	 *非原地，不需要临时图像</span><br><span class="line">	 */</span></span><br><span class="line">	morphologyBlackhat = cvCreateImage(cvGetSize(it), it-&gt;depth, it-&gt;nChannels);</span><br><span class="line">	cvMorphologyEx(it, morphologyBlackhat, NULL, kernel, CV_MOP_BLACKHAT, <span class="number">1</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"morphologyBlackhat"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"morphologyBlackhat"</span>, morphologyBlackhat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	it = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	<span class="comment">//自适应阈值二值化</span></span><br><span class="line">	cvAdaptiveThreshold(gray, it, <span class="number">255</span>, CV_THRESH_BINARY);</span><br><span class="line">	cvNamedWindow(<span class="string">"it"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"it"</span>, it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160214115457.png" alt="原图"><br>依次为开闭运算，形态学梯度<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/initpintu_%E5%89%AF%E6%9C%AC.jpg" alt="开闭运算，形态学梯度"><br>依次为礼帽黑帽<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160214114924.png" alt="礼帽黑帽"></p>
<p>可以看到，开运算中，将Data Matrix码区域连成一片，为以下寻找轮廓或者霍夫线变换作出铺垫。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、简介">一、简介</h1><p><a href="http://tyroneli.com/2016/01/19/OpenCVfindDataMatrix/">上篇</a>中简单介绍了膨胀腐蚀两种基本的形态学操作，这两种操作可以很好的对二值化图像起作用。然而，在处理灰度或者彩色图像时，往往需要更加通用的形态学操作。下面这五种操作都基于膨胀腐蚀进行。</p>
<table><tr><th>操作名称</th><th>形态学操作</th><th>是否需要临时图像</th></tr><tr><td>CV_MOP_OPEN</td><td>开运算</td><td>否</td></tr><tr><td>CV_MOP_CLOSE</td><td>闭运算</td><td>否</td></tr><tr><td>CV_MOP_GRADIENT</td><td>形态学梯度</td><td>是</td></tr><tr><td>CV_MOP_TOPHAT</td><td>礼帽</td><td>原地操作需要</td></tr><tr><td>CV_MOP_BLACKHAT</td><td>黑帽</td><td>原地操作需要</td></tr></table>

<p>操作函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形态学操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvMorphologyEx</span><span class="params">(</span><br><span class="line">					<span class="keyword">const</span> CvArr* src,            //原图像</span><br><span class="line">					CvArr* dst,                  //目标图像</span><br><span class="line">					CvArr* temp,                 //临时图像</span><br><span class="line">					IplConvKernel* element,      //形态学操作卷积核</span><br><span class="line">					<span class="keyword">int</span> operation,               //指定形态学操作</span><br><span class="line">					<span class="keyword">int</span> iterations CV_DEFAULT(1)</span>)</span>;   <span class="comment">//迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置卷积核</span></span><br><span class="line">IplConvKernel* cvCreateStructuringElementEx(</span><br><span class="line">					<span class="keyword">int</span> cols,              </span><br><span class="line">					<span class="keyword">int</span> rows,           <span class="comment">//设置核尺寸为cols*rows</span></span><br><span class="line">					<span class="keyword">int</span> anchor_x,      </span><br><span class="line">					<span class="keyword">int</span> anchor_y,       <span class="comment">//设置核的锚点位置</span></span><br><span class="line">					<span class="keyword">int</span> shape,          <span class="comment">//设置核的形状，一般为矩形</span></span><br><span class="line">					<span class="keyword">int</span>* <span class="function">values <span class="title">CV_DEFAULT</span><span class="params">(NULL)</span>)</span>;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C" scheme="http://ningquec.github.io/tags/C/"/>
    
      <category term="OpenCV" scheme="http://ningquec.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习OpenCV：寻找图像中的Data Matrix区域（1）]]></title>
    <link href="http://ningquec.github.io/2016/01/19/OpenCVfindDataMatrix/"/>
    <id>http://ningquec.github.io/2016/01/19/OpenCVfindDataMatrix/</id>
    <published>2016-01-19T07:23:32.000Z</published>
    <updated>2016-01-22T09:47:47.752Z</updated>
    <content type="html"><![CDATA[<h1 id="一、简介">一、简介</h1><p>Data Matrix是二维码的一种，最大特点就是密度高，其最小尺寸是目前所有条码中最小的。Data Matrix码不同于QR码，由寻边区和数据区组成。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160119174505.png" alt="Data Matrix"><br>这里不对编码具体的细节作介绍，目的主要是根据Data Matrix的特点（“L型”边界）来寻找图像中的疑似Data Matrix区域，这需要很多图像处理算法的结合。<br>图像处理有一个很重要的特征：受到实际情况的影响非常大，同样的算法，可能换个场景就完全失效了。所以，本文就从探索的过程谈起，说一下OpenCV的常见处理算法。<br><a id="more"></a></p>
<h1 id="二、图像处理">二、图像处理</h1><h2 id="1-灰度化">1.灰度化</h2><p>图像灰度化，将多通道彩色图像转换为单通道灰度图像，能大大降低计算机的计算难度。很多算法都只适用于灰度图像，对于二维码识别来说，本身就是由深色块和浅色块表示的“1”和“0”构成，转换为灰度图像是很自然的。<br>灰度图像是仅包含亮度信息不包含色彩信息的图像,把亮度值量化等分成O~255共256个级别,O最暗(全黑)、255最亮(全白)。常见的转为灰度计算公式为为Gray=O.299R+0.587G+0.114B，OpenCV中提供了直接的函数调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvCvtColor</span><span class="params">(<span class="keyword">const</span> CvArr* src, CvArr* dst, CV_BGR2GRAY)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>前两个参数为输入图像和输出图像，第三个用来指定具体的颜色空间转换。本例中将彩色图像转换为灰度图像，所以第三个参数为<code>CV_BGR2RGB</code>。需要注意，原始图像和目标图像的尺寸和深度应保持一致。</p>
<h2 id="2-平滑">2.平滑</h2><p>平滑也称为模糊，现实采集到的图像都存在有大量的噪声，非常影响下一步的计算，需要对其进行平滑处理，降低噪声。比如下图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160122151624.png" alt="降噪"><br>其中difference图片将处理前后的照片相减，可以明显的看出平滑的效果。<br>噪声是存在于图像中的普遍现象。假设，一幅图像中的像素值分布为{1, 1, 1, 1, 10, 1}，其中，10为噪点，我们对其采用中值平滑操作，将每一个值变为其邻域的中值，10就被置换为1了，达到降噪的目的。<br>在OpenCV中，提供了<code>cvSmooth</code>函数，其中包括五种常见的平滑操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvSmooth</span><span class="params">(<span class="keyword">const</span> CvArr* src, </span><br><span class="line">              CvArr* dst, </span><br><span class="line">              <span class="keyword">int</span> smoothtype = CV_GAUSSIAN,</span><br><span class="line">              <span class="keyword">int</span> param1 = 3,</span><br><span class="line">              <span class="keyword">int</span> param2 = 0,</span><br><span class="line">              <span class="keyword">int</span> param3 = 0,</span><br><span class="line">              <span class="keyword">int</span> param4 = 0</span><br><span class="line">             )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>前两个参数为输入和输出图像；soomothtype为平滑操作的类型：包括简单平滑（CV_BLUR）、简单无缩放变换平滑（CV_BLUR_NO_SCALE）、中值平滑（CV_MEDIAN）、高斯平滑（CV_GAUSSIAN）、双边滤波（CV_BILATERAL）；剩下的参数可以简单理解为平滑的核大小，不同操作代表的含义也有细小差别。用一个实际的例子来说明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cv.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;highgui.h&gt;</span></span><br><span class="line"></span><br><span class="line">IplImage* src;</span><br><span class="line">IplImage* gray;</span><br><span class="line">IplImage* blur;</span><br><span class="line">IplImage* noScaleBlur;</span><br><span class="line">IplImage* gaussian;</span><br><span class="line">IplImage* median;</span><br><span class="line">IplImage* bilateral;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smooth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	src = cvLoadImage(<span class="string">"F:\\opencv_pic\\datamatrix8.png"</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Can't load the data matrix image!"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cvNamedWindow(<span class="string">"src"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	gray = cvCreateImage(CvSize(src-&gt;width, src-&gt;height), src-&gt;depth, <span class="number">1</span>);</span><br><span class="line">	cvCvtColor(src, gray, CV_BGR2GRAY);</span><br><span class="line">	smooth();</span><br><span class="line">	cvWaitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smooth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	blur = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	cvSmooth(gray, blur, CV_BLUR, <span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"blur"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"blur"</span>, blur);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无缩放变换的平滑比较特殊，输入和输出的数据类型不能相同，只能输出16S和32f</span></span><br><span class="line">	noScaleBlur = cvCreateImage(cvGetSize(gray), IPL_DEPTH_16S, gray-&gt;nChannels);</span><br><span class="line">	cvSmooth(gray, noScaleBlur, CV_BLUR_NO_SCALE, <span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"noScaleBlur"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"noScaleBlur"</span>, noScaleBlur);</span><br><span class="line"></span><br><span class="line">	median = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	cvSmooth(gray, median, CV_MEDIAN, <span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"median"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"median"</span>, median);</span><br><span class="line"></span><br><span class="line">	median = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	cvSmooth(gray, median, CV_MEDIAN, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"median"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"median"</span>, median);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高斯平滑的原理可以参看http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html</span></span><br><span class="line">	gaussian = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	cvSmooth(gray, gaussian, CV_GAUSSIAN, <span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"gaussian"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"gaussian"</span>, gaussian);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在双边滤波操作中，param1代表高斯核的宽度，与高斯平滑相同；param2越大，表明待滤波的强度范围越大</span></span><br><span class="line">	bilateral = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	cvSmooth(gray, bilateral, CV_BILATERAL, <span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"bilateral"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"bilateral"</span>, bilateral);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/initpintu1.jpg" alt="平滑操作效果"><br>从左至右从上到下依次为：原图、简单平滑、简单无缩放变换平滑、中值平滑、高斯平滑、双边滤波。<br>本例中采取了7作为核的大小，是为了更好的看出各平滑操作的区别。实际操作中要根据具体情况分析，通常会搭配多种平滑操作以期取得最好的效果。<br>为了以后操作的考量，需要保留图像的边缘，以便提取出Data Matrix的特征，建议保留双边滤波。这种平滑操作较之高斯平滑，能够保留边缘，但是需要更多的处理时间。</p>
<h2 id="3-二值化">3.二值化</h2><p>图像二值化是将具有多个灰度级的灰度图像转换为只有两个灰度的黑白图像，便于特征提取。OpenCV提供了单一阈值和自适应阈值两个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单一阈值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cvThresold</span><span class="params">(CvArr* src, CvArr* dst, <span class="keyword">double</span> threshold, <span class="keyword">double</span> max_value, <span class="keyword">int</span> threshold_type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自适应阈值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvAdaptiveThreshold</span><span class="params">(CvArr* src, CvArr* dst, <span class="keyword">double</span> max_val,</span><br><span class="line">                         <span class="keyword">int</span> adaptive_method = CV_ADAPTIVE_THRESH_MEAN_C,</span><br><span class="line">                         <span class="keyword">int</span> threshold_type = CV_THRESH_BINARY,</span><br><span class="line">                         <span class="keyword">int</span> block_size = 3, <span class="keyword">double</span> param1 = 5</span><br><span class="line">                        )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>直接来看示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cv.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;highgui.h&gt;</span></span><br><span class="line"></span><br><span class="line">IplImage* src;</span><br><span class="line">IplImage* gray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryImage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	src = cvLoadImage(<span class="string">"F:\\opencv_pic\\datamatrix1.jpg"</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Can't load the data matrix image!"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cvNamedWindow(<span class="string">"src"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"src"</span>, src);</span><br><span class="line">	gray = cvCreateImage(CvSize(src-&gt;width, src-&gt;height), src-&gt;depth, <span class="number">1</span>);</span><br><span class="line">	cvCvtColor(src, gray, CV_BGR2GRAY);</span><br><span class="line">	binaryImage();</span><br><span class="line">	cvWaitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	it = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	cvThreshold(gray, it, <span class="number">100</span>, <span class="number">255</span>, CV_THRESH_BINARY);</span><br><span class="line">	cvNamedWindow(<span class="string">"it"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"it"</span>, it);</span><br><span class="line"></span><br><span class="line">	iat = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	cvAdaptiveThreshold(gray, iat, <span class="number">255</span>, CV_THRESH_BINARY);</span><br><span class="line">	cvNamedWindow(<span class="string">"iat"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"iat"</span>, iat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图1：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/12.jpg" alt="二值化图1"><br>效果图2：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/123.jpg" alt="二值化图2"><br>采用了两幅图，当背景简单时候，采用单一阈值100的效果明显要好一些，把背景和Data Matrix区域完全分开了，自适应阈值只把边缘找了出来；但是当遇到复杂背景时候，单一阈值完全无法达到目的，Data Matrix区域被抹掉了。<br>也许总能够找到一个恰当的单一阈值来分割目标区域，但自适应阈值的普适性更强，所以项目中最好还是采用自适应阈值。</p>
<h2 id="4-形态学操作">4.形态学操作</h2><p>形态学操作能实现多种功能：例如消除噪声、分割出独立的图像元素以及在图像中连接相邻的元素。形态学也常常被用于寻找图像中的明显的极大值区域或极小值区域以及求图像的梯度。<br>Data Matrix是一个正方形的码，我们可以通过形态学操作来进一步去除噪声，找出疑似Data Matrix连通区域，之后只需在疑似区域内进行更精确的匹配，能够降低后面的计算难度。<br>OpenCV提供两种基本的形态学操作：腐蚀和膨胀；还有五种基于腐蚀膨胀的形态学操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//腐蚀</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvErode</span><span class="params">(IplImage* src, IplImage* dst, IplConvKernel* B = NULL, <span class="keyword">int</span> interations = 1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//膨胀</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvDilate</span><span class="params">(IplImage* src, IplImage* dst, IplConvKernel* B = NULL, <span class="keyword">int</span> interations = 1)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>前两个参数为输入和输出图像；第三个参数指示卷积的核；interations表示操作迭代的次数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cv.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;highgui.h&gt;</span></span><br><span class="line"></span><br><span class="line">IplImage* src;</span><br><span class="line">IplImage* gray;</span><br><span class="line">IplImage* it;</span><br><span class="line">IplImage* erode;</span><br><span class="line">IplImage* dilate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morphlogy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	src = cvLoadImage(<span class="string">"F:\\opencv_pic\\datamatrix8.png"</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (src == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Can't load the data matrix image!"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cvNamedWindow(<span class="string">"src"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	gray = cvCreateImage(CvSize(src-&gt;width, src-&gt;height), src-&gt;depth, <span class="number">1</span>);</span><br><span class="line">	cvCvtColor(src, gray, CV_BGR2GRAY);</span><br><span class="line">	it = cvCreateImage(cvGetSize(gray), gray-&gt;depth, gray-&gt;nChannels);</span><br><span class="line">	cvThreshold(gray, it, <span class="number">100</span>, <span class="number">255</span>, CV_THRESH_BINARY);</span><br><span class="line">	morphlogy()；</span><br><span class="line">	cvWaitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morphlogy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//为了更明显的体现效果，将核的尺寸设置的很大（21*21）</span></span><br><span class="line">	IplConvKernel* kernel = cvCreateStructuringElementEx(<span class="number">21</span>, <span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, CV_SHAPE_RECT);</span><br><span class="line"></span><br><span class="line">	erode = cvCreateImage(cvGetSize(it), it-&gt;depth, it-&gt;nChannels);</span><br><span class="line">	cvErode(it, erode, kernel, <span class="number">1</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"erode"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"erode"</span>, erode);</span><br><span class="line"></span><br><span class="line">	dilate = cvCreateImage(cvGetSize(it), it-&gt;depth, it-&gt;nChannels);</span><br><span class="line">	cvDilate(it, dilate, kernel, <span class="number">1</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"dilate"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"dilate"</span>, dilate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160122172612_%E5%89%AF%E6%9C%AC.png" alt="腐蚀膨胀"><br>需要注意的是，膨胀和腐蚀都是针对图像中的亮区域，所以看到腐蚀使得亮的区域逐渐缩小，黑色的Data Matrix区域连成一片。<br>经过这样的操作，就能很容易的找到图中近似正方形区域，进而筛选出Data Matrix的疑似区域。然而，在实际场景中，很难通过这两个简单的操作找出合适的区域。我这里选用的图像是没有复杂背景的图片，下一篇中，将会介绍其他更为实用的形态学操作。</p>
<h1 id="三、参考文献">三、参考文献</h1><p><a href="http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html" target="_blank" rel="external">阮一峰博客</a><br>《学习OpenCV》<br>DataMatrix二维条码图像识别的算法研究与实现，李雅静，硕士论文</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、简介">一、简介</h1><p>Data Matrix是二维码的一种，最大特点就是密度高，其最小尺寸是目前所有条码中最小的。Data Matrix码不同于QR码，由寻边区和数据区组成。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160119174505.png" alt="Data Matrix"><br>这里不对编码具体的细节作介绍，目的主要是根据Data Matrix的特点（“L型”边界）来寻找图像中的疑似Data Matrix区域，这需要很多图像处理算法的结合。<br>图像处理有一个很重要的特征：受到实际情况的影响非常大，同样的算法，可能换个场景就完全失效了。所以，本文就从探索的过程谈起，说一下OpenCV的常见处理算法。<br>]]>
    
    </summary>
    
      <category term="C" scheme="http://ningquec.github.io/tags/C/"/>
    
      <category term="OpenCV" scheme="http://ningquec.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习OpenCV：Trackbar的几种用法]]></title>
    <link href="http://ningquec.github.io/2016/01/18/OpenCVTrackbar/"/>
    <id>http://ningquec.github.io/2016/01/18/OpenCVTrackbar/</id>
    <published>2016-01-18T07:07:28.000Z</published>
    <updated>2016-01-22T06:25:43.807Z</updated>
    <content type="html"><![CDATA[<h1 id="一、简介">一、简介</h1><p>Highgui包为我们提供了trackbar（滑动条）的实现，利用它我们可以作很多事情。比如视频的拖放、动态传入参数等等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cvCreateTrackbar(</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* trackbar_name, </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* window_name,</span><br><span class="line">    <span class="keyword">int</span>* value, </span><br><span class="line">    <span class="keyword">int</span> count, </span><br><span class="line">    <span class="function">CvTrackbarCallback on_change <span class="title">CV_DEFAULT</span><span class="params">(NULL)</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个参数：滑动条名称；</li>
<li>第二个参数：窗口名称；</li>
<li>第三个参数：滑动条的位置所代表的值；</li>
<li>第四个参数：滑动条的最大值；</li>
<li>第五个参数：回调函数。</li>
</ul>
<h1 id="二、trackbar的几种用法">二、trackbar的几种用法</h1><a id="more"></a>
<h2 id="1-_传入参数">1. 传入参数</h2><p>采用alpha融合公式来融合图像，可以将两幅图带权的相加在一起。融合公式为：<code>dst = alpha* src1 + beta* src2 + gamma</code>。在实际应用中，我们可以利用trackbar动态的调整alpha，beta，gamma的值。效果如图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160118153429.png" alt="alpha融合"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cv.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;highgui.h&gt;</span></span><br><span class="line"></span><br><span class="line">IplImage* background;</span><br><span class="line">IplImage* rain;</span><br><span class="line">IplImage* bg;</span><br><span class="line">IplImage* result;             <span class="comment">//定义图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;                <span class="comment">//存储trackbar位置所代表的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">alphaBlending</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onBlendingBar</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(alphaBlending())&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">alphaBlending</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	background = cvLoadImage(<span class="string">"F:\\opencv_pic\\bg.jpg"</span>, <span class="number">1</span>);</span><br><span class="line">	rain = cvLoadImage(<span class="string">"F:\\opencv_pic\\rain.jpg"</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (background == <span class="number">0</span> || rain == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	bg = cvCreateImage(cvSize(rain-&gt;width, rain-&gt;height), rain-&gt;depth, <span class="number">3</span>);</span><br><span class="line">	cvResize(background, bg, <span class="number">1</span>);               </span><br><span class="line">	result = cvCreateImage(cvSize(rain-&gt;width, rain-&gt;height), rain-&gt;depth, <span class="number">3</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"Blending"</span>, <span class="number">1</span>);</span><br><span class="line">	cvCreateTrackbar(<span class="string">"Blending bar"</span>, <span class="string">"Blending"</span>, &amp;value, <span class="number">100</span>, onBlendingBar);   <span class="comment">//代表位置的值只能接受int类型</span></span><br><span class="line">	cvWaitKey(<span class="number">0</span>);</span><br><span class="line">	cvDestroyWindow(<span class="string">"Blending"</span>);</span><br><span class="line">	cvReleaseImage(&amp;background);</span><br><span class="line">	cvReleaseImage(&amp;bg);</span><br><span class="line">	cvReleaseImage(&amp;rain);</span><br><span class="line">	cvReleaseImage(&amp;result);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onBlendingBar</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> alpha;</span><br><span class="line">	alpha = <span class="keyword">double</span>(value) / <span class="number">100.0</span>;          </span><br><span class="line">	<span class="keyword">double</span> beta = <span class="number">1</span> - alpha;                            <span class="comment">//动态的根据滑动条位置改变alpha、beta的值</span></span><br><span class="line">	cvAddWeighted(bg, alpha, rain, beta, <span class="number">0.0</span>, result);  <span class="comment">//alpha融合</span></span><br><span class="line">	cvShowImage(<span class="string">"Blending"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_作为开关">2. 作为开关</h2><p>不幸的是，Highgui包没有提供任何形式的按钮，实现开关功能只能另辟蹊径。例如，使用只有两个值的滑动条。开关实际上就是只有两个状态的滑动条，这两个状态是“on（1）”和“off（2）”。下面是一个是否显示灰度图的例子。效果如图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160118155116.png" alt="切换灰度彩色"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cv.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;highgui.h&gt;</span></span><br><span class="line"></span><br><span class="line">IplImage* background;</span><br><span class="line">IplImage* result;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isGray</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onGrayBar</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isGray())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isGray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	background = cvLoadImage(<span class="string">"F:\\opencv_pic\\bg.jpg"</span>, <span class="number">1</span>);</span><br><span class="line">	result = cvCreateImage(cvSize(background-&gt;width, background-&gt;height), background-&gt;depth, <span class="number">1</span>);</span><br><span class="line">	cvNamedWindow(<span class="string">"Switch"</span>,<span class="number">1</span>);</span><br><span class="line">	cvCreateTrackbar(<span class="string">"Gray Switcher"</span>, <span class="string">"Switch"</span>, &amp;value, <span class="number">1</span>, onGrayBar);</span><br><span class="line">	cvWaitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onGrayBar</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line">		cvCvtColor(background, result, CV_BGR2GRAY);</span><br><span class="line">		cvShowImage(<span class="string">"Switch"</span>, result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cvShowImage(<span class="string">"Switch"</span>, background);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-拖动视频">3.拖动视频</h2><p>视频其实就是一幅幅图像连起来播放的结果。人眼有0.1秒的“暂留”现象，也就是说1秒内只要平均放映10帧画面，就可以达到动画的效果，目前24帧应用较多。所以要在OpenCV中播放视频，只需把一帧帧画面不停显示出来即可。</p>
<p>读取文件中的视频时，我们要了解CvCapture，CvCapture结构存储了从文件中读取帧所需的信息。我们可以使用下面这个函数来读取视频文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture* cvCreateFileCapture(<span class="keyword">const</span> <span class="keyword">char</span>* filename);</span><br></pre></td></tr></table></figure></p>
<p>创建一个有效的capture结构之后，就可以开始读视频帧：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IplImage* cvQueryFrame(CvCapture* capture);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，在读取每一帧之后，都要停顿一段时间（很短的时间，几十毫秒），否则播放视频会出现一闪而过的情形。下面是具体的程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cv.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;highgui.h&gt;</span></span><br><span class="line"></span><br><span class="line">IplImage* background;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readVidio</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onVidioBar</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	readVidio();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readVidio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	capture = cvCreateFileCapture(<span class="string">"video\\Megamind.avi"</span>);                        <span class="comment">//创建capture</span></span><br><span class="line">	<span class="keyword">if</span> (capture == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cvNamedWindow(<span class="string">"Vidio"</span>, <span class="number">1</span>);                                 </span><br><span class="line">	<span class="keyword">int</span> frames = (<span class="keyword">int</span>)cvGetCaptureProperty(capture, CV_CAP_PROP_FRAME_COUNT);    <span class="comment">//获取帧总数</span></span><br><span class="line">	cvCreateTrackbar(<span class="string">"快进快退"</span>, <span class="string">"Vidio"</span>, &amp;value, frames,onVidioBar);</span><br><span class="line">	<span class="keyword">float</span> fps = cvGetCaptureProperty(capture, CV_CAP_PROP_FPS);</span><br><span class="line">	<span class="keyword">float</span> vfps = <span class="number">1000</span> / fps;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		background = cvQueryFrame(capture);</span><br><span class="line">		<span class="keyword">if</span> (background == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cvShowImage(<span class="string">"Vidio"</span>, background);</span><br><span class="line">		cvWaitKey(vfps);                                                          <span class="comment">//等待一段时间</span></span><br><span class="line">		cvSetTrackbarPos(<span class="string">"快进快退"</span>, <span class="string">"Vidio"</span>, value);                             <span class="comment">//令滑动条随着播放自动滑动</span></span><br><span class="line">		value++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onVidioBar</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">	cvSetCaptureProperty(capture, CV_CAP_PROP_POS_FRAMES, value);</span><br><span class="line">	value = pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果如图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160118161951.png" alt="拖动视频"></p>
<h1 id="三、参考文献">三、参考文献</h1><p>《学习OpenCV》<br><a href="http://blog.csdn.net/column/details/opencv-tutorial.html" target="_blank" rel="external">浅墨博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、简介">一、简介</h1><p>Highgui包为我们提供了trackbar（滑动条）的实现，利用它我们可以作很多事情。比如视频的拖放、动态传入参数等等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cvCreateTrackbar(</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* trackbar_name, </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* window_name,</span><br><span class="line">    <span class="keyword">int</span>* value, </span><br><span class="line">    <span class="keyword">int</span> count, </span><br><span class="line">    <span class="function">CvTrackbarCallback on_change <span class="title">CV_DEFAULT</span><span class="params">(NULL)</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一个参数：滑动条名称；</li>
<li>第二个参数：窗口名称；</li>
<li>第三个参数：滑动条的位置所代表的值；</li>
<li>第四个参数：滑动条的最大值；</li>
<li>第五个参数：回调函数。</li>
</ul>
<h1 id="二、trackbar的几种用法">二、trackbar的几种用法</h1>]]>
    
    </summary>
    
      <category term="C" scheme="http://ningquec.github.io/tags/C/"/>
    
      <category term="OpenCV" scheme="http://ningquec.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习OpenCV：IplImage数据结构和ROI应用]]></title>
    <link href="http://ningquec.github.io/2016/01/15/IplImageStructure/"/>
    <id>http://ningquec.github.io/2016/01/15/IplImageStructure/</id>
    <published>2016-01-15T08:27:29.000Z</published>
    <updated>2016-01-15T08:29:45.127Z</updated>
    <content type="html"><![CDATA[<h1 id="一、前言">一、前言</h1><p>开始学习OpenCV，毕设和工作都要接触。希望能借此机会复习一下数学和C语言。另外插一句：</p>
<blockquote>
<p>大学课程无论看起来多么无用，以后都会是工作实践里的基石。</p>
</blockquote>
<h1 id="二、OpenCV第一课：基本数据类型">二、OpenCV第一课：基本数据类型</h1><p>略去了OpenCV的安装过程，推荐浅墨博客。这里主要讲解OpenCV的常见数据结构。<br><a id="more"></a></p>
<h2 id="1-_矩阵和图像类型">1. 矩阵和图像类型</h2><p>下图显示了如何在OpenCV中一幅图像是如何表示的。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160115162236.png" alt="在OpenCV中表示图像"><br>以上黑白图像是两维的，我们可以把图像分成很多个“点”，每个“点”都有一个明暗程度，用一个数值表示，这样就得到了一个矩阵。计算机里就是用这样的矩阵来表示图像的，<code>“点”被称为像素，它的值被称为灰度</code>。<br>这是黑白图像的情况。<br>假如是彩色图像，我们可以近似的看成，在黑白的基础上增加了一个色彩的维度。因为每一种颜色都可以分解为R、G、B三种颜色，所以我们分配三个矩阵来表示一副彩色图像。第一个矩阵表示Red的值，第二个表示Green，第三个表示Blue。实际应用中，我们把三个矩阵合成了一个：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160115105032.png" alt="彩色图像矩阵"></p>
<ul>
<li>注：OpenCV中，三种元素的排列顺序为BGR。</li>
</ul>
<p>OpenCV的C语言接口使用IplImage数据类型来编码图像。先来看一个实际的例子吧。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "cv.h"              <span class="comment">//图像算法包</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "highgui.h"         <span class="comment">//提供一些显示函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	IplImage* img = cvLoadImage(<span class="string">"Lena.jpg"</span>, <span class="number">1</span>); <span class="comment">//加载图像，参数1表示加载彩色图像</span></span><br><span class="line">	<span class="keyword">if</span> (img != <span class="number">0</span>) &#123;   </span><br><span class="line">		cvNamedWindow(<span class="string">"Lena"</span>, <span class="number">1</span>);         <span class="comment">//命名窗口为“Lena”，参数1表示自动适应图像尺寸</span></span><br><span class="line">		cvShowImage(<span class="string">"Lena"</span>, img);</span><br><span class="line">		cvWaitKey(<span class="number">0</span>);                     <span class="comment">//按0退出窗口</span></span><br><span class="line">		cvDestroyWindow(<span class="string">"Lena"</span>);          <span class="comment">//C语言接口必须要手动释放内存，C++接口则不需要</span></span><br><span class="line">		cvReleaseImage(&amp;img);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160115113607.png" alt="读取图像"><br>IplImage类派生自CvMat类，CvMat类派生自CvArr类，所以我们以后能经常看到函数的参数为CvArr*，把它简单的当做IplImage即可。这里是IplImage的结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IplImage&#123;</span><br><span class="line">	<span class="keyword">int</span> 				 nSize;</span><br><span class="line">	<span class="keyword">int</span> 				 ID;</span><br><span class="line">	<span class="keyword">int</span> 				 nChannels;        <span class="comment">//通道数，3表示彩色，单通道就是灰度图像</span></span><br><span class="line">	<span class="keyword">int</span> 				 AlphaChannel;</span><br><span class="line">	<span class="keyword">int</span> 				 depth;            <span class="comment">//深度，表示图像像素类型</span></span><br><span class="line">	<span class="keyword">int</span> 				 colorModel[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> 				 channelSeq[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> 				 dataOrder;</span><br><span class="line">	<span class="keyword">int</span> 				 origin;           <span class="comment">//设置坐标原点的位置</span></span><br><span class="line">	<span class="keyword">int</span> 				 align;</span><br><span class="line">	<span class="keyword">int</span> 				 width;            <span class="comment">//宽度</span></span><br><span class="line">	<span class="keyword">int</span> 				 height;           <span class="comment">//高度</span></span><br><span class="line">	<span class="keyword">struct</span> _IplROI* 	 roi;              <span class="comment">//感兴趣区域，可以单独对该区域操作</span></span><br><span class="line">	<span class="keyword">struct</span> _IplImage* 	 maskROI;</span><br><span class="line">	<span class="keyword">void</span>*				 imageID;</span><br><span class="line">	<span class="keyword">struct</span> _IplTailInfo* tileInfo;</span><br><span class="line">	<span class="keyword">int</span> 				 imageSize;</span><br><span class="line">	<span class="keyword">char</span>* 				 imageData;</span><br><span class="line">	<span class="keyword">int</span> 				 widthStep;        <span class="comment">//一行的字节数</span></span><br><span class="line">	<span class="keyword">int</span> 				 BorderMode[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">int</span> 				 BorderConst[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">char</span>* 				 imageDataOrigin;</span><br><span class="line">&#125; IplImage;</span><br></pre></td></tr></table></figure></p>
<p>下面用一个例子看看IplImage的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &#34;stdafx.h&#34;&#10;#include &#34;cv.h&#34;&#10;#include &#34;highgui.h&#34;&#10;&#10;int main(void)&#123;&#10;&#9;IplImage* img;&#10;&#9;if ((img = cvLoadImage(&#34;Lena.jpg&#34;, 1)) != 0) &#123;&#10;&#9;&#9;cvNamedWindow(&#34;Lena&#34;, 1);&#10;&#9;&#9;cvShowImage(&#34;Lena&#34;, img);&#10;&#9;&#9;cvWaitKey(0);&#10;&#9;&#9;printf(&#34;&#22270;&#20687;depth&#20026;: %d\n&#34;, img-&#62;depth);&#10;&#9;&#9;printf(&#34;&#22270;&#20687;width&#20026;: %d\n&#34;, img-&#62;width);&#10;&#9;&#9;printf(&#34;&#22270;&#20687;height&#20026;: %d\n&#34;, img-&#62;height);&#10;&#9;&#9;printf(&#34;&#22270;&#20687;widthStep&#20026;: %d\n&#34;, img-&#62;widthStep);&#10;&#9;&#9;cvDestroyWindow(&#34;Lena&#34;);&#10;&#9;&#9;cvReleaseImage(&#38;img);&#10;&#9;&#9;return 0;&#10;&#9;&#125;&#10;    return -1;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160115151249.png" alt="结果图"></p>
<h2 id="2-_ROI详解">2. ROI详解</h2><p>计算机视觉的任务均为计算密集型，在很多情况下，使用ROI能提高计算机视觉代码的执行速度。这是因为设定ROI允许对图像的一小部分区域做操作，而不是对整个图像进行计算。设置ROI和取消ROI用<code>cvSetImageROI()</code>和<code>cvResetImageROI()</code>函数。<br>这里是一个利用ROI叠加图片的例子。先来看结果：<br>logo图片：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160115161941.png" alt="Logo图片"><br>南大北大楼图片：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160115161950.png" alt="南大北大楼"><br>结果图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20160115162006.png" alt="利用ROI合成图"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "stdafx.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cv.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;highgui.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	IplImage* njuSrc = cvLoadImage(<span class="string">"NJU1.jpg"</span>, <span class="number">1</span>);</span><br><span class="line">	IplImage* logoSrc = cvLoadImage(<span class="string">"NJU2.jpg"</span>, <span class="number">1</span>);</span><br><span class="line">	IplImage* logo = cvCreateImage(CvSize(logoSrc-&gt;width/<span class="number">3</span>,logoSrc-&gt;height/<span class="number">3</span>),logoSrc-&gt;depth,logoSrc-&gt;nChannels);</span><br><span class="line">	cvResize(logoSrc, logo, <span class="number">1</span>);                            <span class="comment">//缩小logo图为原来的1/3</span></span><br><span class="line">	<span class="keyword">if</span> (njuSrc == <span class="number">0</span> || logo == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Fail to load image!"</span>);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IplImage* mask = cvCreateImage(CvSize(logoSrc-&gt;width / <span class="number">3</span>, logoSrc-&gt;height / <span class="number">3</span>), logoSrc-&gt;depth, <span class="number">1</span>);</span><br><span class="line">	cvCvtColor(logo, mask, CV_BGR2GRAY);                   <span class="comment">//制作掩膜图像</span></span><br><span class="line">	uchar* data = (uchar *)mask-&gt;imageData;</span><br><span class="line">	<span class="keyword">int</span> step = mask-&gt;widthStep / <span class="keyword">sizeof</span>(uchar);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask-&gt;width; i++) &#123;                <span class="comment">//将mask图像反色</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mask-&gt;height; j++) &#123;</span><br><span class="line">			data[i*step + j] = <span class="number">255</span> - data[i*step + j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cvSetImageROI(njuSrc, cvRect(<span class="number">0</span>, <span class="number">0</span>, logo-&gt;width, logo-&gt;height));   <span class="comment">//设定ROI区域</span></span><br><span class="line">	cvCopy(logo, njuSrc,mask);                                        <span class="comment">//将logo拷贝到图像ROI区域中</span></span><br><span class="line">	cvNamedWindow(<span class="string">"ROI Test"</span>, <span class="number">1</span>);</span><br><span class="line">	cvShowImage(<span class="string">"ROI Test"</span>, njuSrc);</span><br><span class="line">	cvWaitKey(<span class="number">0</span>);</span><br><span class="line">	cvDestroyWindow(<span class="string">"ROI Test"</span>);</span><br><span class="line">	cvReleaseImage(&amp;njuSrc);</span><br><span class="line">	cvReleaseImage(&amp;logoSrc);</span><br><span class="line">	cvReleaseImage(&amp;logo);</span><br><span class="line">	cvReleaseImage(&amp;mask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、前言">一、前言</h1><p>开始学习OpenCV，毕设和工作都要接触。希望能借此机会复习一下数学和C语言。另外插一句：</p>
<blockquote>
<p>大学课程无论看起来多么无用，以后都会是工作实践里的基石。</p>
</blockquote>
<h1 id="二、OpenCV第一课：基本数据类型">二、OpenCV第一课：基本数据类型</h1><p>略去了OpenCV的安装过程，推荐浅墨博客。这里主要讲解OpenCV的常见数据结构。<br>]]>
    
    </summary>
    
      <category term="C" scheme="http://ningquec.github.io/tags/C/"/>
    
      <category term="OpenCV" scheme="http://ningquec.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio安装的几个坑]]></title>
    <link href="http://ningquec.github.io/2016/01/13/FirstAndroidProblem/"/>
    <id>http://ningquec.github.io/2016/01/13/FirstAndroidProblem/</id>
    <published>2016-01-13T06:09:57.000Z</published>
    <updated>2016-01-14T05:38:28.084Z</updated>
    <content type="html"><![CDATA[<h2 id="一、前言">一、前言</h2><p>毕设题目是做一个基于Android的字符识别。作为一个有Java基础（擅长hello world）的程序员，自下载Android Studio遭遇无数个坑，这里做一下记录。</p>
<h2 id="二、坑">二、坑</h2><ol>
<li>下载安装包看清楚自己需要的<br>官方的安装包都在墙外，下载速度不能保证，推荐网盘搜索~<br>还可以看<a href="https://github.com/inferjay/AndroidDevTools" target="_blank" rel="external">这里</a>。</li>
<li><p>提示未安装build-tool-21.1.1<br><strong>解决办法：</strong></p>
<ul>
<li>下载<a href="http://dl-ssl.google.com/android/repository/build-tools_r21.1.1-windows.zip" target="_blank" rel="external">build-tools21.1.1（墙外）</a>，不能翻墙的就自己搜一下吧。</li>
<li>C:\Users\&lt;用户名&gt;\AppData\Local\Android\sdk\build-tools，在本路径下建立新的文件夹：21.1.1。</li>
<li>下载build-tools21.1.1解压，把文件夹中所有东西拷贝到21.1.1下。</li>
<li>重启Android Studio。</li>
</ul>
</li>
<li><p>运行APP出现：HAX is not working and emulator runs in emulation mode<br>安装HAXM时候设置的内存小于你AVD的内存，可能就会报这样的错误。<br><strong>解决办法：</strong></p>
<ul>
<li>调低AVD的内存，比如768M。</li>
<li>重新安装HAXM，在<a href="https://software.intel.com/en-us/android/articles/intel-hardware-accelerated-execution-manager" target="_blank" rel="external">这儿</a>下载。<ul>
<li>卸载原来的HAXM：控制面板-&gt;卸载Intel® Hardware Accelerated Execution Manager。</li>
<li>安装下载的安装包，选择合适的内存。</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、前言">一、前言</h2><p>毕设题目是做一个基于Android的字符识别。作为一个有Java基础（擅长hello world）的程序员，自下载Android Studio遭遇无数个坑，这里做一下记录。</p>
<h2 id="二、坑">二、坑</h2><o]]>
    </summary>
    
      <category term="Android" scheme="http://ningquec.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速排序的两种方法（java & Go实现）]]></title>
    <link href="http://ningquec.github.io/2015/08/20/QuickSort/"/>
    <id>http://ningquec.github.io/2015/08/20/QuickSort/</id>
    <published>2015-08-20T12:29:47.000Z</published>
    <updated>2015-08-20T12:33:39.672Z</updated>
    <content type="html"><![CDATA[<p>快速排序的基本思想就是分治：</p>
<ol>
<li>选择一个基准数字</li>
<li>将数组中比基准数字小的放在基准数字左边，大的放在右边</li>
<li>对基准数字分成的两个区域重复第二步，直至每个区间只有一个数</li>
</ol>
<p>所以快速排序的平均时间复杂度为O(nlog_2n)。n是每一趟复杂度，log_2n则是分区的次数。下面两种方法都遵循分治的基本思想，所不同的只是分区的方法。</p>
<p>一、挖坑法<br>如图，每一趟排序的原理如下：</p>
<ol>
<li>把最左边的元素作为基准数字（也可以任意选择），储存在temp中，作为第一个“坑”</li>
<li>i引用自区域最左边始，j引用自区域最右边始</li>
<li>j从右向左遍历，当遇到比基准数字小的数字时，填入“坑”，原地形成一个“坑”</li>
<li>i从左向右遍历，当遇到比基准数字大的数字时，填入“坑”，原地形成一个“坑”</li>
<li>重复3,4步，直到i=j时候停下</li>
<li>将基准数字放入i位置的“坑”中</li>
</ol>
<a id="more"></a>
<p><img src="http://7xjnnt.com1.z0.glb.clouddn.com/52755791966578285.jpg" alt="挖坑法"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> java.lang.Exception	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [] array =&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">65</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">		<span class="keyword">new</span> QuickSort().sort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">		System.out.println(array[i]+ <span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">	        <span class="keyword">int</span> temp = array[left];</span><br><span class="line">		    <span class="keyword">int</span> i = left;</span><br><span class="line">		    <span class="keyword">int</span> j = right;</span><br><span class="line">		    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">		        <span class="keyword">while</span>(i&lt;j &amp;&amp; array[j] &gt;= temp)&#123;</span><br><span class="line">		            j--;</span><br><span class="line">		        &#125;</span><br><span class="line">		        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">		            array[i++] = array[j];</span><br><span class="line">		        &#125;</span><br><span class="line">		        <span class="keyword">while</span>(i&lt;j &amp;&amp; array[i] &lt; temp)&#123;</span><br><span class="line">		            i++;</span><br><span class="line">		        &#125;</span><br><span class="line">		        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">		            array[j--] = array[i];</span><br><span class="line">		        &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">		    array[i] = temp;</span><br><span class="line">		    sort(array, left, i-<span class="number">1</span>);</span><br><span class="line">			sort(array, i+<span class="number">1</span>, right);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> quick(values []<span class="typename">int</span>, i <span class="typename">int</span>, j <span class="typename">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">		temp := values[i]</span><br><span class="line">		left := i</span><br><span class="line">		right := j</span><br><span class="line">		<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">			<span class="keyword">for</span> left &lt; right &amp;&amp; values[right] &gt;= temp &#123;</span><br><span class="line">				right--</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">				values[left] = values[right]</span><br><span class="line">				left++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> left &lt; right &amp;&amp; values[left] &lt; temp &#123;</span><br><span class="line">				left++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">				values[right] = values[left]</span><br><span class="line">				right--</span><br><span class="line">			&#125;</span><br><span class="line">			values[left] = temp</span><br><span class="line">			quick(values, i, left-<span class="number">1</span>)</span><br><span class="line">			quick(values, left+<span class="number">1</span>, j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	values := []<span class="typename">int</span>&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">	quick(values, <span class="number">0</span>, <span class="built_in">len</span>(values)-<span class="number">1</span>)</span><br><span class="line">	fmt.Print(values)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、优化版本<br>如图，每一趟排序的原理如下：</p>
<ol>
<li>将最右边的数字作为基准数字</li>
<li>j指向最左边元素，i指向最左边元素的左边</li>
<li>j向右遍历，找到比基准数字小的就停下，与++i位置上的数字交换</li>
<li>重复3，直到j指向基准数字前一个</li>
<li>交换基准数字和++i位置的数字</li>
</ol>
<p><img src="http://7xjnnt.com1.z0.glb.clouddn.com/622715335369222192.jpg" alt="优化版"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> java.lang.Exception	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [] array =&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">65</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">		<span class="keyword">new</span> QuickSort().sort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">		System.out.println(array[i]+ <span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">			<span class="keyword">int</span> i = left-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> j = left;</span><br><span class="line">			<span class="keyword">int</span> temp = array[right];</span><br><span class="line">			<span class="keyword">while</span>(j&lt;right)&#123;</span><br><span class="line">				<span class="keyword">while</span>(temp&lt;array[j])&#123;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(j&lt;right)&#123;</span><br><span class="line">					<span class="keyword">int</span> k = array[j];</span><br><span class="line">					array[j++] = array[++i];</span><br><span class="line">					array[i] = k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			array[right] = array[++i];</span><br><span class="line">			array[i]=temp;</span><br><span class="line">			sort(array,left,i-<span class="number">1</span>);</span><br><span class="line">			sort(array,i+<span class="number">1</span>,right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> sort(values []<span class="typename">int</span>, left <span class="typename">int</span> ,right <span class="typename">int</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> left&lt;right &#123;</span><br><span class="line">		temp := values[right]</span><br><span class="line">		i := left - <span class="number">1</span></span><br><span class="line">		j := left </span><br><span class="line">		<span class="keyword">for</span> j &lt; right &#123;</span><br><span class="line">			<span class="keyword">for</span> values[j] &gt; temp &#123;</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> i&lt;j&#123;</span><br><span class="line">				i++</span><br><span class="line">				values[i],values[j] = values[j],values[i]</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">		temp,values[i] = values[i],temp</span><br><span class="line">		sort(values,left,i-<span class="number">1</span>)</span><br><span class="line">		sort(values,i+<span class="number">1</span>,right)			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> main() &#123;</span><br><span class="line">	values := []<span class="typename">int</span> &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">52</span>,<span class="number">1</span>,<span class="number">74</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">	sort(values,<span class="number">0</span>,<span class="built_in">len</span>(values)-<span class="number">1</span>)</span><br><span class="line">	fmt.Print(values)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>快速排序的基本思想就是分治：</p>
<ol>
<li>选择一个基准数字</li>
<li>将数组中比基准数字小的放在基准数字左边，大的放在右边</li>
<li>对基准数字分成的两个区域重复第二步，直至每个区间只有一个数</li>
</ol>
<p>所以快速排序的平均时间复杂度为O(nlog_2n)。n是每一趟复杂度，log_2n则是分区的次数。下面两种方法都遵循分治的基本思想，所不同的只是分区的方法。</p>
<p>一、挖坑法<br>如图，每一趟排序的原理如下：</p>
<ol>
<li>把最左边的元素作为基准数字（也可以任意选择），储存在temp中，作为第一个“坑”</li>
<li>i引用自区域最左边始，j引用自区域最右边始</li>
<li>j从右向左遍历，当遇到比基准数字小的数字时，填入“坑”，原地形成一个“坑”</li>
<li>i从左向右遍历，当遇到比基准数字大的数字时，填入“坑”，原地形成一个“坑”</li>
<li>重复3,4步，直到i=j时候停下</li>
<li>将基准数字放入i位置的“坑”中</li>
</ol>]]>
    
    </summary>
    
      <category term="Go" scheme="http://ningquec.github.io/tags/Go/"/>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="数据结构" scheme="http://ningquec.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Servlet学习笔记（一）]]></title>
    <link href="http://ningquec.github.io/2015/08/09/ServletDay1/"/>
    <id>http://ningquec.github.io/2015/08/09/ServletDay1/</id>
    <published>2015-08-09T14:05:36.000Z</published>
    <updated>2015-08-09T14:11:51.996Z</updated>
    <content type="html"><![CDATA[<h2 id="一、servlet简介">一、servlet简介</h2><p>Servlet是Sun公司提供的一门用于开发动态web资源的技术。Servlet接受并且响应从客户端发送的请求，一般遵循http协议。<br>编写一个servlet的方法很简单：</p>
<ul>
<li>编写一个java类，实现servlet接口</li>
<li>把开发好的java类部署到web服务器中</li>
</ul>
<p>servlet接口定义了一系列方法来进行：初始化servlet，响应请求、 从服务器移除servlet。<br>这些方法是生命周期相关的方法（life-cycle methods），并且按照以下顺序执行。</p>
<ol>
<li>servlet被创建时，调用初始化方法。init()</li>
<li>客户端发出请求时，响应请求方法就被执行。service()</li>
<li>servlet从服务器移除之时，调用移除的方法。 destroy()</li>
</ol>
<a id="more"></a>
<h2 id="二、service()方法响应请求过程">二、service()方法响应请求过程</h2><p>客户端通过service()方法与服务器端通信。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, java.io.IOException</span></span><br></pre></td></tr></table></figure></p>
<p>req是客户端发起的ServletRequest对象，res是服务器端相应的ServletResponse对象。</p>
<p>例如一个简单的HelloWorld程序。</p>
<ol>
<li>在Tomcat中建立一个web应用。webapps/NewWebName/WEB-INF/classes目录</li>
<li>在classes目录中建立FirstServlet.java。</li>
<li>将servlet的支持jar包加入到环境变量中。</li>
<li>在WEB-INF目录中建立web.xml文件，配置web文件对外访问路径。</li>
<li>启动Tomcat。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FirstServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.sevlet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, java.io.IOException</span>&#123;</span><br><span class="line">		OutputStream out = res.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"Hello, Servlet!!"</span>.getBytes());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--     web.xml         --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">    <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span><br><span class="line">    <span class="attribute">version</span>=<span class="value">"2.5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>web.servlet.FirstServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/FirstServlet<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下图详细说明了一个servlet的工作流程。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/绘图1.jpg" alt="servlet顺序图"></p>
<h2 id="三、HttpServlet类">三、HttpServlet类</h2><p>如果要implements Servlet接口，那么需要自己实现里面的每个方法。<br>SUN为了简便开发，提供了两个默认的实现类：GenericServlet和HttpServlet，我们只需要继承这两个实现类即可。</p>
<p>HttpServlet指能够处理HttpServlet请求的Servlet，它在原有的接口上添加了一些Http协议处理方法，通常在开发中继承这一个类。<br>HttpServlet在实现接口时，重写了service()方法。接收来自 public service 方法的标准 HTTP 请求，并将它们分发给此类中定义的 doXXX 方法。此方法是 javax.servlet.Servlet#service 方法的特定于 HTTP 的版本。</p>
<ul>
<li>doGet，如果 servlet 支持 HTTP GET 请求</li>
<li>doPost，用于 HTTP POST 请求</li>
<li>doPut，用于 HTTP PUT 请求</li>
<li>doDelete，用于 HTTP DELETE 请求</li>
</ul>
<h2 id="四、servlet的一些重要细节">四、servlet的一些重要细节</h2><h3 id="（1）地址映射">（1）地址映射</h3><p>由于客户端是通过URL地址访问web应用资源，所以Servlet程序要想被外部访问，一定要把servlet程序映射到一个URL地址上。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">web-app</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span><br><span class="line">	&lt;servlet-name&gt;设置servlet的名称；</span><br><span class="line">	&lt;servlet-class&gt;设置servlet的完整类名。</span><br><span class="line">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>web.servlet.FirstServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span><br><span class="line">	&lt;url-pattern&gt;设置Servlet的对外访问路径。</span><br><span class="line">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/FirstServlet<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>同时要注意的是，同一个Servlet可以映射多个URL地址。</p>
<h3 id="（2）Servlet对象创建">（2）Servlet对象创建</h3><p>针对客户端的多次Servlet请求，通常情况下，服务器只会创建一个Servlet对象。<br>也就是说，Servlet对象一旦创建，就会驻留在内存中，直至web容器退出，Servlet实例对象才会被摧毁。<br>在Servlet的整个生命周期内，init()方法只会被调用一次，而service()方法会因为多次请求而多次被调用。</p>
<h3 id="（3）&lt;load-on-start&gt;元素">（3）<code>&lt;load-on-start&gt;</code>元素</h3><p>如果在<servlet>元素中配置了<code>&lt;load-on-start&gt;</code>元素，那么web应用在启动时，就会装载并创建Servlet实例对象，以及调用init()方法。<br>比如，可以为web应用写一个InitServlet，这个Servlet会在启动时装载，为整个web应用创建必要的数据库表和数据。</servlet></p>
<p><load-on-start>内的数字表示该Servlet的优先级，数字越小，优先级越高。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">load-on-start</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-start</span>&gt;</span></span><br></pre></td></tr></table></figure></load-on-start></p>
<h3 id="（4）Servlet缺省设置">（4）Servlet缺省设置</h3><p>如果某个Servlet的映射路径仅仅是一个正斜杠“/”，那么这个Servlet就成为了缺省Servlet。凡是在web.xml文件中找不到匹配的<servlet-mapping>元素的URL，都一律交给缺省Servlet处理。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></servlet-mapping></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、servlet简介">一、servlet简介</h2><p>Servlet是Sun公司提供的一门用于开发动态web资源的技术。Servlet接受并且响应从客户端发送的请求，一般遵循http协议。<br>编写一个servlet的方法很简单：</p>
<ul>
<li>编写一个java类，实现servlet接口</li>
<li>把开发好的java类部署到web服务器中</li>
</ul>
<p>servlet接口定义了一系列方法来进行：初始化servlet，响应请求、 从服务器移除servlet。<br>这些方法是生命周期相关的方法（life-cycle methods），并且按照以下顺序执行。</p>
<ol>
<li>servlet被创建时，调用初始化方法。init()</li>
<li>客户端发出请求时，响应请求方法就被执行。service()</li>
<li>servlet从服务器移除之时，调用移除的方法。 destroy()</li>
</ol>]]>
    
    </summary>
    
      <category term="JavaWeb" scheme="http://ningquec.github.io/tags/JavaWeb/"/>
    
      <category term="Servlet" scheme="http://ningquec.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎么写一个www.baidu.com]]></title>
    <link href="http://ningquec.github.io/2015/08/03/FakeBaiduCom/"/>
    <id>http://ningquec.github.io/2015/08/03/FakeBaiduCom/</id>
    <published>2015-08-03T14:08:21.000Z</published>
    <updated>2015-08-03T14:55:25.493Z</updated>
    <content type="html"><![CDATA[<p>当我们在浏览器地址栏键入www.baidu.com并回车，就会显示出baidu的主页.<br>但是我想输入之后，能够显示出我的主页，一定是很炫酷的。</p>
<p>怎么改？首先要弄明白背后的原理。</p>
<a id="more"></a>
<h2 id="一、输入网址到显示页面发生了啥">一、输入网址到显示页面发生了啥</h2><h3 id="(1)输入网址">(1)输入网址</h3><h3 id="(2)浏览器查找网址对应的IP地址">(2)浏览器查找网址对应的IP地址</h3><p>浏览器会去请求网址所对应的主机里的资源，所以问题就变成了：怎么在主机群里找到那个她？</p>
<p>每一台主机都会分配一个唯一的IP地址，你可以通过这个地址来精确锁定到她。但是用一串形似194.1.5.48的数字来称呼她也太难记了，所以每一个IP地址都有一个“别名”—域名，比如baidu.com就是百度的域名。</p>
<p>你键入了域名，浏览器就会到DNS服务器里去取域名和IP地址的映射。<br>但是每次都麻烦DNS会很慢，所以在某几个地方也会缓存这样的映射。并且按照以下顺序搜索。</p>
<ul>
<li>浏览器缓存。浏览器会缓存一段时间的DNS记录。时间不确定。</li>
<li>系统缓存。在windows中有一个host文件，其中保存了一些DNS的记录，也可以自己编辑。</li>
<li>路由器缓存。路由器一般也会有自己的DNS缓存。</li>
<li>ISP DNS缓存（互联网运营商的DNS缓存）。一般都能在这里找到的。</li>
</ul>
<h3 id="（3）浏览器发送get请求">（3）浏览器发送get请求</h3><p>找到目标主机之后，得告诉对方你要干啥。</p>
<h3 id="（4）服务的永久重定向响应">（4）服务的永久重定向响应</h3><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<code>http://www.baidu.com</code>而非<code>http://baidu.com</code>。</p>
<p>为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？这个问题有好多有意思的答案。<br>其中一个原因跟搜索引擎排名有关。<br>你看，如果一个页面有两个地址，就像<code>http://www.baidu.com</code>和<code>http://baidu.com</code>，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。<br>而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。<br>还有一个是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p>
<h3 id="（5）浏览器再次请求，主机处理请求">（5）浏览器再次请求，主机处理请求</h3><h2 id="二、主机怎么对外提供web应用">二、主机怎么对外提供web应用</h2><h3 id="一个web应用由多个静态和动态的web资源组成。">一个web应用由多个静态和动态的web资源组成。</h3><ul>
<li>html、css、js文件</li>
<li>Jsp、支持jar包、java文件</li>
<li>配置文件<h3 id="服务器管理（以TomCat为例）">服务器管理（以TomCat为例）</h3>外界是怎么访问自己的web资源呢？需要你有一个网络程序来控制访问，比如下面这样：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">2222</span>);</span><br><span class="line">		Socket sock = server.accept();</span><br><span class="line">		</span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\baidu\\fake\\baidu.html"</span>);</span><br><span class="line">		OutputStream out = sock.getOutputStream();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">while</span>((length = in.read(buffer)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			out.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">		&#125;</span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line">		sock.close();</span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>总不能为了不同web应用开发不同的网络程序吧，所以服务器就产生了。不需要你写繁琐的程序，只需要遵照一定的规则配置、开发即可。</p>
<p>（1）服务器TomCat的目录层次结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#65306;&#23384;&#25918;&#21551;&#21160;&#21644;&#20851;&#38381;TomCat&#30340;&#33050;&#26412;&#25991;&#20214;&#10;conf&#65306;&#23384;&#25918;TomCat&#26381;&#21153;&#22120;&#30340;&#21508;&#31181;&#37197;&#32622;&#25991;&#20214;&#65288;&#27604;&#22914;server.xml&#65289;&#10;lib&#65306;&#23384;&#25918;TomCat&#26381;&#21153;&#22120;&#30340;&#25903;&#25745;jar&#21253;&#10;logs&#65306;&#23384;&#25918;TomCat&#26381;&#21153;&#22120;&#30340;&#26085;&#24535;&#10;temp&#65306;&#23384;&#25918;TomCat&#26381;&#21153;&#22120;&#36816;&#34892;&#26102;&#20135;&#29983;&#30340;&#20020;&#26102;&#25991;&#20214;&#10;webapps&#65306;web&#24212;&#29992;&#25152;&#22312;&#30446;&#24405;&#65292;&#21363;&#20379;&#22806;&#30028;&#35775;&#38382;&#30340;web&#36164;&#28304;&#30340;&#23384;&#25918;&#30446;&#24405;&#10;work&#65306;&#23384;&#25918;TomCat&#26381;&#21153;&#22120;&#30340;&#24037;&#20316;&#30446;&#24405;</span><br></pre></td></tr></table></figure></p>
<p>（2）配置<br>Web应用开发好了以后，若想供外界访问，需要把Web应用所在目录交给服务器管理，也就是虚拟目录的映射。例如下面这种配置方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--          配置文件：conf/server.xml                --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">Host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">Context</span> <span class="attribute">path</span>=<span class="value">"tyrone"</span> <span class="attribute">docBase</span>=<span class="value">"C:\java"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Host</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是在实际开发中，这种配置不行。因为它要重写服务器，所以每次重写都要重启服务器来使其生效。可以采用其他方式：</p>
<ol>
<li>配置在\$CATALINA_BASE/conf/context.xml，这样context会对所有的webapps生效。</li>
<li>配置在\$CATALINA_BASE/conf/[enginename]/[hostname]/context.xml，这样context会对当前的host的所有webapps生效。</li>
<li>配置在\$CATALINA_BASE/conf/[enginename]/[hostname]/dictionary，在这之下任意写入一个xml文件，xml文件的名称就成为了虚拟路径。</li>
<li>TomCat服务器会自动管理webapps目录下的所有web应用，并且把它映射为虚拟目录。也就是说，webapps目录下的web应用，外界可以直接访问。<br>（3）web应用的目录结构<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/snapshot20150802211403.jpg" alt="web应用目录"></li>
</ol>
<p>web.xml是其中最为重要的文件，所有的web应用下的资源都可以用web.xml来管理。</p>
<h2 id="三、干活儿">三、干活儿</h2><p>掌握了以上知识，就可以通过键入www.baidu.com来访问自己的博客了。<br>（1）web资源<br>在TomCat的所在盘符，建立一个baidu文件：F:\baidu；<br>在baidu文件夹下，建立一个fake文件夹，在其中建立baidu.html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"refresh"</span> <span class="attribute">content</span>=<span class="value">"0;url=http://tyroneli.com/"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样在访问这个html页面时就会自动的跳转到我的博客页面。<br>（2）配置<br>在通过TomCat访问webapps的时候，我们一般会在浏览器中这样输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/webpath/1.html</span><br></pre></td></tr></table></figure></p>
<p>localhost是本地电脑的名字，8080是访问本地电脑的8080端口，webpath是虚拟地址，1.html就是要访问的web资源。<br>现在我想要将上面的地址形式替换为<code>www.baidu.com</code>，怎么办呢？</p>
<p>打开TomCat安装目录下的conf/server.xml。添加一个host。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Host</span> <span class="attribute">name</span>=<span class="value">"www.baidu.com"</span> <span class="attribute">appBase</span>=<span class="value">"F:\baidu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">context</span> <span class="attribute">path</span>=<span class="value">""</span> <span class="attribute">docBase</span>=<span class="value">"F:baidu\fake"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Host</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们还要干掉输入的8080端口，当使用http协议时，端口的缺省值为80，所以把conf/server.xml中的<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Connector</span> <span class="attribute">port</span>=<span class="value">"8080"</span> <span class="attribute">protocol</span>=<span class="value">"HTTP/1.1"</span> </span><br><span class="line">               <span class="attribute">connectionTimeout</span>=<span class="value">"20000"</span> </span><br><span class="line">               <span class="attribute">redirectPort</span>=<span class="value">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Connector</span> <span class="attribute">port</span>=<span class="value">"80"</span> <span class="attribute">protocol</span>=<span class="value">"HTTP/1.1"</span> </span><br><span class="line">               <span class="attribute">connectionTimeout</span>=<span class="value">"20000"</span> </span><br><span class="line">               <span class="attribute">redirectPort</span>=<span class="value">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>最后我们还应该删掉地址中请求的具体web资源，也就是不需要输入1.html，直接打开。这样需要把1.html设置为主页。<br>配置主要需要到fake文件夹下面建立一个WEB-INF文件夹，在其中建立web.xml，内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span><br><span class="line">  Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="line">  contributor license agreements.  See the NOTICE file distributed with</span><br><span class="line">  this work for additional information regarding copyright ownership.</span><br><span class="line">  The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="line">  (the "License"); you may not use this file except in compliance with</span><br><span class="line">  the License.  You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">  Unless required by applicable law or agreed to in writing, software</span><br><span class="line">  distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">  See the License for the specific language governing permissions and</span><br><span class="line">  limitations under the License.</span><br><span class="line">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">    <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span><br><span class="line">    <span class="attribute">version</span>=<span class="value">"2.5"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">welcome-file</span>&gt;</span>baidu.html<span class="tag">&lt;/<span class="title">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">welcome-file-list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>（3）欺骗浏览器<br>现在我们配置好了，如果直接键入地址栏，是万万不行的。<br>还记得DNS的查找顺序吗？我们可以更改host文件里的DNS记录，将www.baidu.com映射为本机的IP地址。位置在C:\Windows\System32\drivers\etc\hosts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#20320;&#30340;&#26412;&#26426;ip&#22320;&#22336;]  www.baidu.com</span><br></pre></td></tr></table></figure></p>
<p>大功告成，在浏览器里试试吧~试验过后记得恢复现场。</p>
<h2 id="图示">图示</h2><p><img src="http://7xjnnt.com1.z0.glb.clouddn.com/670776200857479428.jpg" alt="请求图示"><br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/389552964248002933.jpg" alt="伪造图示"></p>
<h2 id="总结">总结</h2><p>这是一个标题党。<br>以后会介绍一下真正的搜索引擎是怎么工作的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>当我们在浏览器地址栏键入www.baidu.com并回车，就会显示出baidu的主页.<br>但是我想输入之后，能够显示出我的主页，一定是很炫酷的。</p>
<p>怎么改？首先要弄明白背后的原理。</p>]]>
    
    </summary>
    
      <category term="JavaWeb" scheme="http://ningquec.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试的那些事]]></title>
    <link href="http://ningquec.github.io/2015/07/28/HowToInterview/"/>
    <id>http://ningquec.github.io/2015/07/28/HowToInterview/</id>
    <published>2015-07-28T12:27:30.000Z</published>
    <updated>2015-07-30T14:23:43.155Z</updated>
    <content type="html"><![CDATA[<p>在java研发的面试中，有一些问题的出现频度非常的高。<br>为什么面试官们总是喜欢问集合类，喜欢问多线程？为什么希望我们掌握spring框架，掌握sql，掌握web相关知识？<br>如果在求职网站上做一下简单的统计，爬取公司的招聘简章，不难发现规律。java相关职位的热词前6名分别是<b>java，spring，web，mysql，Oracle，Linux</b>。</p>
<p>我们可以从以上获悉一些职业的知识需求以及未来的发展方向。</p>
<ul>
<li>注：以下只是个人见解，妄自揣测，并不一定准确。</li>
</ul>
<a id="more"></a>
<h2 id="一、java基础知识部分">一、java基础知识部分</h2><h3 id="（1）jvm和GC">（1）jvm和GC</h3><p>知识点：jvm如何加载类，内存如何分配、分配多少，不同区域的职能是什么，如何协同工作，垃圾收集什么时候会发生，如何判断是否需要回收，不同区域的回收算法是否相同，什么情况下会发生内存泄露，为什么会出现栈溢出或者内存溢出……等等。</p>
<p>可能刚开始接触java觉得掌握了基本语法，能编写程序就算是了解了。但这是远远不够的。<br>我们不知道为什么java可以“一处编写，到处运行”，也不知道出现内存错误应该如何去排查，不知道怎么才能避免内存瓶颈带来的程序性能问题，更不知道如何根据实际来配置jvm内存大小（GC浪费时间）。这都是我们可以从jvm的知识中学到的。</p>
<h3 id="（2）“==”和equals有什么区别">（2）“==”和equals有什么区别</h3><p>这个问题我被很多公司问过，深挖一下，还真的被问倒了。<br>你可能觉得知道“==”是比较对象是否相同，equals是比较对象的内容是否相同就足够了。然而我们需要了解更多。<br>比如Object类中的equals是什么作用，String里的equals是什么作用，它们的实现是一样吗？一些集合类中，比如set，它是怎么判重的呢？</p>
<p>在实际项目中，equals方法经常要重写（注意满足自反、对称、传递），我们如果不了解基本知识，很难写出一个完美的equals方法，也就很难去合理的判断对象是否相同了。</p>
<h3 id="（3）HashMap的底层实现">（3）HashMap的底层实现</h3><p>这个问题不仅考了对java常用API的了解，也可以顺便考一下Hash表的数据结构。我们可能仅仅停留在熟练使用的阶段，知道它是存储键值对的。这仍然不够。</p>
<p>实际应用中，我们需要选择合适的HashMap初始大小，因为resize()操作是最为费时的；我们可能还要考虑多线程的环境下，是否要使用ConCurrentHashMap；还有每一次填写表单，比如用户名密码，它的背后可能都是HashMap，假如有人获知了Hash算法，恶意的提交会产生碰撞的表单，就能够明显的拖慢响应速度。</p>
<p>其他的集合类API也大致类似，比如ArrayList、LinkedList的装载因子，扩容步长，尽量少用Stack、vector，什么容器是线程安全的，什么时候需要用iterator，什么是快速失败机制，他有啥用？这都是我们需要掌握的。</p>
<h3 id="（4）final,_finally,_finalize的区别">（4）final, finally, finalize的区别</h3><p>final是很重要的关键字，可以用在变量、方法和类上。finally用于异常处理，finalize用于垃圾回收。</p>
<p>这是比较细节的问题了，不仅要问，还要拉出三兄弟来撑场面，虽然除了长得像，没啥一样的。因为在实际应用中，我们经常会碰到它们。<br>final会带来哪些好处，修饰方法时运行跟普通的方法运行有啥区别？finally经常用于实现状态的清理，比如Lock的释放，为什么要放在finally里面执行？finalize可以垃圾回收，那么，是它说了算，还是System.gc()说了算，还是都不算？</p>
<h3 id="（5）常见的RuntimeException">（5）常见的RuntimeException</h3><p>NullPointerException：空指针引用异常。ArrayIndexOutOfBoundsException：数组下标越界异常。FileNotFoundException：文件未找到异常<br>ClassCastException：类型强制转换异常。NumberFormatException：字符串转换为数字类型时抛出的异常。<br>等等。</p>
<p>这个可能只是考我们的积累。但是我们需要的不只是知道这些异常，还要知道什么可能出现的异常是我们要去catch的。RuntimeException编译器会帮忙检查；Error很严重，jvm只好选择死亡。剩下的可以称做可查异常，包括除了RuntimeException以外的异常，这些是需要我们try catch的。<br>这样有什么用呢？企业级的项目，自然是稳定性最为重要，有这样系统级的保证才能使得程序便于维护。通过抛出异常，我们将错误确定的交给某一层去捕捉，并且获知异常信息，这是保证程序健壮（robust）的重要手段。同时要注意，仅仅printStackTrace并不足够，可以提起通知、修正问题或者把异常转为更容易被别人理解的异常。</p>
<h3 id="（6）实现同步的方法">（6）实现同步的方法</h3><p>这个不用多说，看看BAT这样的互联网公司，并发编程肯定是大大的有用。<br>synchronized、volatile、wait和notify、Lock、ThreadLocal。</p>
<h3 id="（7）IO流">（7）IO流</h3><p>开发一个产品，总不能让用户只用控制台来交互吧(也是IO)，当然要掌握IO流的知识。<br>首先要分清字节流字符流，分清一层一层的封装是为了什么目的，也要知道每个类的API怎么用。在开发中，经常需要持久化操作，序列化反序列化是重要的IO使用范例。IO还是网络通信的基础。</p>
<h3 id="（8）java三大特性">（8）java三大特性</h3><p>这个压轴出场，因为它是基石。<br>面向对象的三大特性：封装，继承，多态。</p>
<h2 id="二、数据库部分">二、数据库部分</h2><p>这部分一般问的问题没有那么聚集，有职位的关系，也有数据库有好几种的原因。比如做数据库方面的工具开发会考察一些sql语句，使用MySql的公司会问几种常用的引擎等等。这里我想举个实际中的例子。<br>因为希望追踪一个支付账单的前世今生，所以需要脚本来自动的从不同服务器上load数据。<br>应该是很简单的呀，无非把数据从不同的表里拿出来输出到一张新表里嘛。需要注意的就是数据表是水平分割的，set起来不就行了。<br>简单测试过之后，就提交运行了。<br>。。。<br>。。。<br>。。。<br>。。。<br>运行了206个小时34分钟若干秒。<br>只好给DBA review一下代码，拿回来之后代码焕然一新。<br>我把join表的操作一股脑的丢给了where子句，而且where子句里面的索引根本就没起作用，还偷懒使用select *。<br>还有一些其他的扩展性问题，比如直接把时间范围写死，而不是传参数进去等等毛病。<br>还有循环的从不同服务器上load数据，不同的服务器为啥不并行来load？</p>
<p>SQL语句都会写，怎么写好，避免低级错误才是我们现在的正确之道。<br>所以我们除了事务特性，SQL语法等基础知识，还需要掌握一些简单的优化，总不能在开发工具时候都指望DBA来做吧？<br>例如：索引的建立以及何时生效，怎样让查询缓存生效，B树索引和hash索引的区别等等。</p>
<h2 id="三、算法题">三、算法题</h2><p>算法题目就是面试时候用的，leetcode、剑指offer这些就是抱佛脚用的，那么问题来了，算法工程师是招来干啥的？<br>很多人都有这样的错觉，工作里用不到这些的呀。</p>
<p>我个人是比较赞同算法面试的，可以训练自己对于边界条件、时间复杂度的理解。算法并不是一些面试中所歪曲的那样。<br>比如判断链表有环问题，设置两个指针，一个走一步一个走两步，如果发生重合就说明存在环。这是一个非常巧妙值得深思的问题，然而这道题我被问了不下4次，早就心生厌倦了。像这样的奇思妙想，出现的多了也就变成一道梗而已。</p>
<p>更合适的是一道链表逆置问题，也是出现频率很高的问题，但是至少可以看出对于指针（引用）的操作是否考虑完全，至于临界的情况以及最后把原本的头指针指向null则是可以临时训练的。</p>
<p>再比如atoi()的实现，里面存在好多种边界条件，如果能独立的思考，逐渐的补全所有没考虑到的情况，也就达到刷题的目的了。<br>我准备算法题目的路径：七大排序—&gt;基本数据结构—&gt;剑指offer—&gt;leetcode。</p>
<p>那么算法学了以后有什么用呢？<br>不然你以为谷歌的rank-page怎么弄的，新闻分类怎么分的？百度的分词怎么做的？淘宝的小图片怎么存储的？窃以为，不想学好算法的程序员不是一个好程序员。</p>
<h2 id="四、设计模式">四、设计模式</h2><p>设计模式是武功秘籍，照着练就行，学会至少田伯光，融会贯通大概是独孤求败了。<br>我现在还是随便被快刀砍挂的路人甲。</p>
<p>设计模式在项目中的体现可能还感触不深，我先说说几个在JDK中用到的设计模式。<br>抽象工厂模式-java.sql包；装饰者模式-java.io；代理模式-reflect类中的Proxy（spring）；<br>享元模式-String常量池。</p>
<p>设计模式看起来很无聊，可以先掌握几个简单的模式：单例模式，工厂模式，抽象工厂模式，适配器模式，装饰者模式，观察者模式。<br>学习时候，最好实现程序以及画出类图。这就要求我们先要搞懂接口和继承，继承和组合，组合和聚合等的区别。<br>因为实践太少的原因，还是不能更深的设计模式含义，所以就不赘述了。</p>
<h2 id="五、总结">五、总结</h2><p>回过头看看，满满的实用主义。<br>生活里还是需要一些“无用功”的，比如喂马劈柴，比如瞎想，比如看风景。<br>恩，等我写完这一篇给面试官看的文章就去。<br>真的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在java研发的面试中，有一些问题的出现频度非常的高。<br>为什么面试官们总是喜欢问集合类，喜欢问多线程？为什么希望我们掌握spring框架，掌握sql，掌握web相关知识？<br>如果在求职网站上做一下简单的统计，爬取公司的招聘简章，不难发现规律。java相关职位的热词前6名分别是<b>java，spring，web，mysql，Oracle，Linux</b>。</p>
<p>我们可以从以上获悉一些职业的知识需求以及未来的发展方向。</p>
<ul>
<li>注：以下只是个人见解，妄自揣测，并不一定准确。</li>
</ul>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Static的一些实验]]></title>
    <link href="http://ningquec.github.io/2015/07/25/JavaStatic/"/>
    <id>http://ningquec.github.io/2015/07/25/JavaStatic/</id>
    <published>2015-07-25T03:11:29.000Z</published>
    <updated>2015-07-28T13:58:32.469Z</updated>
    <content type="html"><![CDATA[<p>java中，一切都是对象。我们通常先new出类的实例：对象，然后通过对象来操作变量和方法。<br>事无绝对，有些情况下我们也需要“全局”的变量和方法。</p>
<a id="more"></a>
<h2 id="一、简单用法">一、简单用法</h2><p>（1）静态变量<br>每一个对象的数据空间都不相同，也就是说我们操作的变量都是一份拷贝。如果我们希望不同的对象能够同时操作某变量的同一份拷贝，就可以用static来修饰。<br>jvm只为静态变量分配一次内存，在加载类的时候完成内存分配，可以用类名直接访问。所以在对象之间共享变量或者为了方便使用时，可以将变量设置为static。<br>（2）static代码块<br>static代码块是比较特殊的，他可以放在类的任何地方，只会在类加载的时候运行一次。<br>下面这个例子说明了static变量和static块初始化的过程。</p>
<ol>
<li>创建StaticTest对象时，发现没有加载该类。需要先加载；</li>
<li>StaticTest类中的static成员变量先执行初始化；</li>
<li>初始化static代码块；</li>
<li>初始化非静态成员变量；</li>
<li>加载完毕，执行new StaticTest()，自动调用构造函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Sample sam=<span class="keyword">new</span> Sample(<span class="string">"静态成员sam初始化"</span>);</span><br><span class="line">	Sample sam1=<span class="keyword">new</span> Sample(<span class="string">"sam1成员初始化"</span>);</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">	   System.out.println(<span class="string">"static块执行"</span>);</span><br><span class="line">	   <span class="keyword">if</span>(sam==<span class="keyword">null</span>)</span><br><span class="line">		   System.out.println(<span class="string">"sam is null"</span>);</span><br><span class="line">	   sam=<span class="keyword">new</span> Sample(<span class="string">"静态块内初始化sam成员变量"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	StaticTest()&#123;</span><br><span class="line">	     System.out.println(<span class="string">"Test默认构造函数被调用"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	      </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">	    StaticTest a=<span class="keyword">new</span> StaticTest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">	Sample(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Sample()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sample默认构造函数被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#38745;&#24577;&#25104;&#21592;sam&#21021;&#22987;&#21270;&#10;static&#22359;&#25191;&#34892;&#10;&#38745;&#24577;&#22359;&#20869;&#21021;&#22987;&#21270;sam&#25104;&#21592;&#21464;&#37327;&#10;sam1&#25104;&#21592;&#21021;&#22987;&#21270;&#10;Test&#40664;&#35748;&#26500;&#36896;&#20989;&#25968;&#34987;&#35843;&#29992;</span><br></pre></td></tr></table></figure></p>
<p>（3）静态方法<br>如果我们希望不通过创建对象，就能直接调用方法，可以将之设置为静态的。我们用的Math类下的各种方法，就是直接通过类名调用方法的例子。<br>需要注意，静态方法内部是不可以调用非静态成员的，这很容易理解。<br>非静态成员需要依赖对象存在，假如被调用的时候对象还没有被创建出来，那该成员自然也是不存在的。例如最常见的main函数，被声明为static，就是因为此时可能还没有创建对象。</p>
<h2 id="二、静态内部类">二、静态内部类</h2><p>一般情况下，类不能被static修饰，只有当类作为内部类出现时才可以。这样做的好处是啥呢？</p>
<p>一般的内部类在使用时都要先实例化外部类，然后通过外部类来调用内部类。静态内部类可以直接作为一个普通的类来使用，不需要获取外部类的“通行证”。多个外部类的对象可以共享同一个内部类的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">		MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">11</span> ;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">this</span>.count&gt;<span class="number">0</span>)</span><br><span class="line">					System.out.println(<span class="string">"count = "</span> + <span class="keyword">this</span>.count--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上模拟卖出10张票的情况。MyRunnable类是一个静态内部类，不需要先生成RunnableTest类的对象，即可直接使用。<br>此处使用了runnable接口，这样，建立的线程t1，t2就是共享MyRunnable对象的count变量了。如果直接继承自Thread类，可以看到t1，t2均卖出10张票。<br>同时，因为count—并非一个原子操作，不加synchronized关键字可能出现如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = 9&#10;count = 10&#10;count = 8&#10;count = 7&#10;count = 5&#10;count = 6&#10;count = 4&#10;count = 2&#10;count = 3&#10;count = 1</span><br></pre></td></tr></table></figure></p>
<h2 id="三、static_synchronized">三、static synchronized</h2><p>那么对于同时使用了synchronized和static的方法，会是什么样呢？比如t1线程进入了这种方法，t2线程还能不能进入到其他synchronized方法呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printInt</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="string">"424242"</span>);  </span><br><span class="line">        &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)  &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="string">"Hello World!"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">		RunnableTest test = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								test.printInt();</span><br><span class="line">							&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">								e.printStackTrace();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								printString();</span><br><span class="line">							&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">								e.printStackTrace();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">424242&#10;Hello World!&#10;Hello World!&#10;424242&#10;424242&#10;Hello World!&#10;424242&#10;Hello World!&#10;Hello World!&#10;424242&#10;424242&#10;Hello World!&#10;424242&#10;Hello World!&#10;424242&#10;Hello World!&#10;Hello World!&#10;424242&#10;424242&#10;Hello World!</span><br></pre></td></tr></table></figure></p>
<p>也就是说，两个synchronized方法同时被线程执行了！<br>static的方法属于类方法，它属于这个Class。当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在的类所对应的Class对象。<br>Java中，无论一个类有多少个对象，这些对象会对应唯一一个Class对象。<br>所以这两个synchronized方法，一个是类锁，一个是对象锁，自然可以一起执行了。</p>
<p>思考一下，假如是两个static syncronized方法，都锁在类上，自然会顺序执行。<br>假如是两个非静态syncronized方法，都锁在对象上，所以如果创建两个对象持有该方法，也可以一起执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printInt</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)  &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="string">"424242"</span>);  </span><br><span class="line">        &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)  &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            System.out.println(<span class="string">"Hello World!"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">		RunnableTest test = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">		RunnableTest testq = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								test.printInt();</span><br><span class="line">							&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">								e.printStackTrace();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								testq.printString();</span><br><span class="line">							&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">								e.printStackTrace();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">424242</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="number">424242</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="number">424242</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>java中，一切都是对象。我们通常先new出类的实例：对象，然后通过对象来操作变量和方法。<br>事无绝对，有些情况下我们也需要“全局”的变量和方法。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正则表达式解决方程是否有解问题]]></title>
    <link href="http://ningquec.github.io/2015/07/14/RELinearEquation/"/>
    <id>http://ningquec.github.io/2015/07/14/RELinearEquation/</id>
    <published>2015-07-14T11:22:24.000Z</published>
    <updated>2015-07-14T11:32:24.756Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>部分译自<a href="http://blog.stevenlevithan.com/archives/algebra-with-regexes" target="_blank" rel="external">http://blog.stevenlevithan.com/archives/algebra-with-regexes</a></p>
</blockquote>
<p>正则表达式在数学上的应用是弱项。对于一个正则表达式引擎来说，0~9这10个字符是最为特殊的。</p>
<p>必须说明Perl和PCRE是个例外，它们允许在匹配进程中的任何一点插入执行动态代码，这也显示了它们的巨大潜力。Perl可以在正则表达式中插入代码，PCRE可以调用外部函数。总的来说，用正则表达式解决数学问题是永远的隐痛。</p>
<p>然而，最基本的正则表达式也可以榨出更多美味的汁来。它甚至可以<a href="http://coolshell.cn/articles/2704.html" target="_blank" rel="external">匹配素数</a>。下面的例子可能让你更加惊艳：<b>正则表达式能判断线性方程是否有解！</b></p>
<p>基本正则表达式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(.*)\1&#123;A&#8722;1&#125;(.*)\2&#123;B&#8722;1&#125;$</span><br></pre></td></tr></table></figure></p>
<p>其中A和B为占位符，使用时候用未知数的系数替换。这里会看的很迷糊，最下面再解释。例如17x+12y=51，A和B就被分别替换为17和12。如果我们将51的字符串代入来匹配，第一个子表达式结果会是3，第二个子表达式会是0，表示x=3，y=0，也就是说这个方程有解。如果方程无解，正则表达式就匹配失败；如果方程有多组解，正则表达式会匹配到x最大的情况。</p>
<p>注意，这样只是看起来很酷。其实正则引擎匹配时会发生多次回溯，某些情况下效率相当低……</p>
<hr>
<p>首先介绍一下如何匹配，还是以17x+12y=51为例。<br>正则表达式代入A和B：<code>^(.*)\1{16}(.*)\2{11}$</code>。前半部分(.*)\1{16}表示先匹配一个(.*),即任意个重复字符，假定为“11”，那么然后会重复匹配16次“11”。后半部分同理。<br>在匹配的时候，我们会先把51转换为一个“11……11”（共51个1）的字符串，然后进行匹配。<br>我们之所以将A、B减去1是因为我们已经在子表达式中（括号中的部分）匹配了一次模式。</p>
<p>下面说明一下其数学原理：<br>我们把(.*)看做是(1*)，即匹配若干个1。匹配成功的情况为：<br>1.匹配一个“111”，剩下51-3=448个1。<br>2.重复16次“111”，共16*3=48。<br>3.51个1匹配成功。<br>4.后半部分(.*)\2{11}重复匹配12次空串，(.*)此时为0个1。</p>
<p>也就是说，正则表达式匹配方程是否有解其实是利用了类似穷举的方式。在最开始，正则引擎可能尝试了以17个空串开头、17个“1”开头、17个“11”开头的情况，类似于尝试17*0+12y=51、17*1+12y=51、17*2+12y=51，但都无法得出恰当的y来完成匹配。</p>
<p>假如我想要匹配一个7位数，17x+12y=1700012。其中的一组解为x=100000，y=1，正则引擎要从0个1试验到100000个1开头……它看了这个七位数一眼，一眼就是万年……</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>部分译自<a href="http://blog.stevenlevithan.com/archives/algebra-with-regexes" target="_blank" rel="external">http://blog.steven]]>
    </summary>
    
      <category term="正则表达式" scheme="http://ningquec.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK1.8中的HashMap介绍和思考]]></title>
    <link href="http://ningquec.github.io/2015/07/11/CollectionHashMap/"/>
    <id>http://ningquec.github.io/2015/07/11/CollectionHashMap/</id>
    <published>2015-07-11T05:36:49.000Z</published>
    <updated>2015-07-12T09:01:36.739Z</updated>
    <content type="html"><![CDATA[<h2 id="一、简介">一、简介</h2><blockquote>
<p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</blockquote>
<ol>
<li>用来存储键值对（Key-Value）。所以我们可以用它来快速匹配映射关系，例如词串的出现次数、国家的首都、小游戏中状态是否合法等等。</li>
<li>是一个散列表。所以它存取较快，同时需要好的hash函数和碰撞处理。</li>
</ol>
<p>JDK1.8以前，HashMap采用“拉链法”来实现：如图，使用数组+链表来处理冲突。使用hash函数得到一个数组索引，同一个Hash值的键值对存储在一个链表里。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/20130314151321_611.jpg?imageView2/0/w/400/" alt="拉链法图示"><br>当链表很长的时候，会导致查询速度变慢，所以在这个版本中，将链表做了一点小小的改动。当链表长度超过8时，链表将转化为一棵红黑树，这样查找时间就从O(n)降低到了O(log_2n)。下面就通过源码来讲解一下HashMap的具体实现。<br><a id="more"></a></p>
<h2 id="二、HashMap的实现">二、HashMap的实现</h2><h3 id="（1）数据结构">（1）数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点数据结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;  <span class="comment">//next指向下一个节点，处理hash冲突</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	<span class="comment">//重写hashCode()，key和value的hashCode()相异或</span></span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="comment">//当key和value都相等时，说明两个节点相等</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储节点的数组</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储被修改的次数</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//临界值，当临界值大于容量*加载因子时，需要进行扩容</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子，默认为0.75，即实际的元素占容量的75%</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）初始化一个HashMap">（2）初始化一个HashMap</h3><p>HashMap的默认初始容量为16（<code>Node&lt;K,V&gt;[] table</code>的长度为16），最大容量为<code>1&lt;&lt;30</code>，默认装载因子为0.75。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></p>
<p>HashMap提供了四个构造函数来初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//初始容量应该大于0</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        <span class="comment">//初始容量不能超过最大容量</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="comment">//装载因子应该大于0</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap使用tableSizeFor()方法来保证HashMap的容量一定为2的整数次幂。原因在下面说明。</p>
<h3 id="（3）put方法">（3）put方法</h3><p><img src="http://7xjnnt.com1.z0.glb.clouddn.com/72586658458581450.jpg" alt="put图示"></p>
<ol>
<li>判断<code>Node&lt;K,V&gt;[] table</code>是否合法，是否需要执行resize操作</li>
<li>通过hash&amp;（数组长度-1）得到索引位置。</li>
<li>如果该节点不存在，新建一个插入，否则更新节点内容。</li>
</ol>
<p>可以看到put方法计算数组索引是通过和Node数组长度(length)减一得到的。如果容量不是2的整数次幂，length-1的最后一位一定是0，同hash值相与的结果最后一位一定也是0.<br>也就是说，索引位置一定出现在偶数位，这是不符合保持均匀的基本要求的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">//如果数组为空或者长度为0，执行resize扩容</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="comment">//hash&amp;（数组长度-1）得到索引位置</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            	<span class="comment">//如果索引位置冲突，且带插入节点的key值已经存在</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            	<span class="comment">//如果是一个红黑树节点，说明链表已经变为红黑树，调用树的插入方法</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                	<span class="comment">//如果链表中没有找到Key相同的节点，则新建节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            	<span class="comment">//对于hash和Key的值都相同的节点，更新其value</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）get方法">（4）get方法</h3><p>get方法的基本思想同put()相同</p>
<ol>
<li>检验<code>Node&lt;K,V&gt;[] table</code>是否合法</li>
<li>通过hash&amp;（数组长度-1）得到索引位置。</li>
<li>遍历链表或者红黑树，找到节点。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="keyword">int</span> hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp;  ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="（5）resize方法">（5）resize方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            	<span class="comment">//如果原始容量超过了最大容量，那么就不能扩容了，只能增大临界值。</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 扩容为原来的两倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">//如果原始容量&lt;=0且临界值&lt;=0（相当于需要重新初始化）使用默认容量和默认临界值。              </span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    	<span class="comment">//对于原始HashMap中的元素，要重新计算索引位置</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; </span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】以上几种方法均需要分链表和红黑树进行讨论。</p>
<h2 id="一些思考">一些思考</h2><p>以前介绍Hash表时说，采用线性探测法处理碰撞时最好令装载因子为0.5，也就是占总容量一半时性能最佳。这是对于空间和时间复杂度的一种权衡。<br>同理，HashMap中也做了这样的权衡。装载因子过高虽然减少了空间开销，但同时也增加了查询成本。<br>在设置初始容量时应该考虑到映射中所需的条目数及其装载因子，以便最大限度地减少resize()操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 resize()操作。 </p>
<p>如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 resize() 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。</p>
<p>JDK1.8中基于查询插入速度的考量，当链表太长时将链表自动转换为红黑树。<br>我最开始的想法是，Hash函数的选择一般都很能保证均匀性，链表有可能在达到临界值之前，长度达到8以上吗？</p>
<p>设想一种极端情况：hash函数被别人获知，不停的恶意put hash值映射索引相同的键值对，此时的链表会不断变长，查询效率就会越来越低。然而元素的总个数还远远没有达到容量*loadFactor的地步（假设容量很大）。这样使用红黑树就能大大降低时间了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、简介">一、简介</h2><blockquote>
<p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</blockquote>
<ol>
<li>用来存储键值对（Key-Value）。所以我们可以用它来快速匹配映射关系，例如词串的出现次数、国家的首都、小游戏中状态是否合法等等。</li>
<li>是一个散列表。所以它存取较快，同时需要好的hash函数和碰撞处理。</li>
</ol>
<p>JDK1.8以前，HashMap采用“拉链法”来实现：如图，使用数组+链表来处理冲突。使用hash函数得到一个数组索引，同一个Hash值的键值对存储在一个链表里。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/20130314151321_611.jpg?imageView2/0/w/400/" alt="拉链法图示"><br>当链表很长的时候，会导致查询速度变慢，所以在这个版本中，将链表做了一点小小的改动。当链表长度超过8时，链表将转化为一棵红黑树，这样查找时间就从O(n)降低到了O(log_2n)。下面就通过源码来讲解一下HashMap的具体实现。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="集合类" scheme="http://ningquec.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[shell脚本编程小技巧]]></title>
    <link href="http://ningquec.github.io/2015/07/10/ShellProgrammingSkills/"/>
    <id>http://ningquec.github.io/2015/07/10/ShellProgrammingSkills/</id>
    <published>2015-07-10T13:21:27.000Z</published>
    <updated>2015-07-22T07:53:56.525Z</updated>
    <content type="html"><![CDATA[<p>总结的一些shell小技巧，时时更新中。。</p>
<p>（1）使用&amp;&amp;和||的短路特性，假如传递了参数，PARAM=参数，否则给PARAM赋一个值。（简化if else）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -n &#34;$1&#34; ]] &#38;&#38; PARAM=$1 || PARAM=value</span><br></pre></td></tr></table></figure></p>
<p>（2）测试上一个命令的退出状态，将错误写入log文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $? &#8211;gt 0 ] &#38;&#38; echo &#39;Something Wrong, please investigate!&#39; &#62;&#62; $&#123;LOG_FILE&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）脚本中产生的一些文件，比如log之类记得最后赋以合适的权限和群组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -type f -mtime -1 &#8211;user `whoami` -exec chmod 777 &#123;&#125; \;&#10;find -type f -mtime -1 &#8211;user `whoami` -exec chgrp group &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>（4）删除掉脚本中的无用空行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#34;^$ d&#34; file</span><br></pre></td></tr></table></figure></p>
<p>（5）测试脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -n script #&#26816;&#27979;&#35821;&#27861;&#65292;&#19981;&#20250;run&#33050;&#26412;&#10;sh -x script #shell&#22312;&#25191;&#34892;&#33050;&#26412;&#30340;&#36807;&#31243;&#20013;&#25226;&#23427;&#23454;&#38469;&#25191;&#34892;&#30340;&#27599;&#19968;&#20010;&#21629;&#20196;&#34892;&#26174;&#31034;&#20986;&#26469;&#65292;&#24182;&#19988;&#22312;&#34892;&#39318;&#26174;&#31034;&#19968;&#20010;&#34;+&#34;&#21495;&#12290; &#10;&#10;&#10;#&#34;+&#34;&#21495;&#21518;&#38754;&#26174;&#31034;&#30340;&#26159;&#32463;&#36807;&#20102;&#21464;&#37327;&#26367;&#25442;&#20043;&#21518;&#30340;&#21629;&#20196;&#34892;&#30340;&#20869;&#23481;&#65292;&#26377;&#21161;&#20110;&#20998;&#26512;&#23454;&#38469;&#25191;&#34892;&#30340;&#26159;&#20160;&#20040;&#21629;&#20196;&#12290;&#10;#&#22312;&#36305;&#33050;&#26412;&#20043;&#21069;&#25191;&#34892;sh &#8211;n &#26159;&#24456;&#22909;&#30340;&#20064;&#24815;&#65292;-x&#21487;&#20197;&#24110;&#21161;&#25105;&#20204;&#20851;&#27880;&#21040;&#36816;&#31639;&#32467;&#26524;&#65292;&#36923;&#36753;&#21028;&#26029;&#32467;&#26524;&#65292;&#21464;&#37327;&#36171;&#20540;&#31561;&#31561;&#12290;</span><br></pre></td></tr></table></figure></p>
<p>（6）将一部分必要的环境配置写入文件，并且在脚本开始调用该文件。例如配置sas环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAS_HOME=sas_path/sas&#10;SAS_TEST=&#8221;$&#123;SAS_HOME&#125; -nonews -stdio -nosyntaxcheck&#34;</span><br></pre></td></tr></table></figure></p>
<p>同时使用恰当的alias能简洁脚本，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias grep=&#34;grep &#8211;rE --color&#34;&#10;alias c=&#39;clear&#39;&#10;alias x=&#39;exit&#39;&#10;alias ll=&#39;ls -l&#39;&#10;alias ldir=&#39;ls -l | grep &#34;^d&#34;&#39;</span><br></pre></td></tr></table></figure></p>
<p>（7）判断脚本中一个数组为空的时候，不能使用<code>if [-z ${ array[@]}]</code>。因为<code>-z</code>智能判断一个变量是否为空。应该使用<code>if [ S{array[@]} -eq 0]</code>，通过数组元素的个数来判断。</p>
<p>（8）使用<code>rm</code>命令千万千万慎重！尽可能的使用绝对路径，对于不确定性或者非常重要的，一定先进行备份。当然你也可以自己重新定义一下rm命令，让它先执行备份操作，再进行删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#19979;&#38754;&#36825;&#20010;&#20363;&#23376;&#24403;$&#123;path&#125;&#20026;&#31354;&#26102;&#65292;&#30011;&#38754;&#22826;&#32654;&#65306;&#20320;&#25191;&#34892;&#20102;rm &#8211;rf *&#10;rm -rf $&#123;path&#125;/*&#10;#&#19979;&#38754;&#21516;&#29702;&#65292;cd&#19968;&#26086;&#22833;&#36133;&#65292;&#30011;&#38754;&#22826;&#32654;&#10;cd to_del&#10;rm -rf *</span><br></pre></td></tr></table></figure></p>
<p>（9）就在我写完第8条，我差点重演了携程一幕。我要寻找一个名字中包含“test”字串的txt文件并删除，所以我想着该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path &#8211;name &#8220;txt&#8221; -exec grep -l &#8220;test&#8221; &#123;&#125; \; -exec rm &#123;&#125;\;</span><br></pre></td></tr></table></figure></p>
<p>我偏不，我一定要xargs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path &#8211;name &#8220;txt&#8221; -exec grep -l &#8220;test&#8221; &#123;&#125; \; | xargs rm -rf</span><br></pre></td></tr></table></figure></p>
<p>是的，我敲完命令的一瞬间就发现脑抽了，grep操作的是txt文件的内容而不是文件名，可怕的是我正好有一个txt文件中包含了很多脚本的路径。<br>假如让这个命令执行完，容易想到会导致什么：把文件内容里包含test的脚本全删除掉了。幸好及时的ctrl-c中断了命令，检查脚本，还都在。。。<br>接下来第一件事就是设置别名rm = ”rm -i” ，之后觉得不稳妥，将rm改为一个mv命令，将要删除的文件放置到tmp文件中，以后只需要crontab删除就好。。。至今仍心有余悸。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>总结的一些shell小技巧，时时更新中。。</p>
<p>（1）使用&amp;&amp;和||的短路特性，假如传递了参数，PARAM=参数，否则给PARAM赋一个值。（简化if else）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -n &#34;$1&#34; ]] &#38;&#38; PARAM=$1 || PARAM=value</span><br></pre></td></tr></table></figure></p>
<p>（2）测试上一个命令的退出状态，将错误写入log文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $? &#8211;gt 0 ] &#38;&#38; echo &#39;Something Wrong, please investigate!&#39; &#62;&#62; $&#123;LOG_FILE&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）脚本中产生的一些文件，比如log之类记得最后赋以合适的权限和群组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -type f -mtime -1 &#8211;user `whoami` -exec chmod 777 &#123;&#125; \;&#10;find -type f -mtime -1 &#8211;user `whoami` -exec chgrp group &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树（二）：红黑树续篇]]></title>
    <link href="http://ningquec.github.io/2015/07/07/DataStructureRBT2/"/>
    <id>http://ningquec.github.io/2015/07/07/DataStructureRBT2/</id>
    <published>2015-07-07T13:23:50.000Z</published>
    <updated>2015-07-08T14:21:34.815Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>1.每个节点只能是黑色或者红色。<br>2.根节点为黑色。<br>3.红色节点的儿子必须都是黑色。<br>4.对每个节点，从该节点到其子孙节点的所有路径上包含相同数目的黑节点（黑色平衡）。</p>
</blockquote>
<p>回顾一下红黑树的重要性质，下面讨论红黑树的删除操作。<br>红黑树的删除同样是按照二叉查找树的方式查找待删除节点，之后需要考虑在不违反以上性质的情况下删除该节点。<br><a id="more"></a><br>首先找出待删除节点的后继节点x，替换待删除节点的位置。为什么用后继节点替换在<a href="http://tyroneli.com/2015/06/22/DataStructureBST/" target="_blank" rel="external">二叉查找树</a>中有提到。<br>同样的，我们约定几个变量。y为删除的节点，x为y后继节点，也就是新的需调整节点，xp为x的父节点，xpp为xp的父节点，xppl为xpp的左孩子。。类推。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4696169845330901090.jpg?imageView2/0/w/400/h/300" alt="变量图示"><br>（一）删除单支红色节点y，这种情况直接删除，不影响黑色平衡。<br>（二）待删除的节点y为黑色，用后继节点x替换，且x为红色。此时将x变为黑色即可。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/5386089682175726007.jpg" alt="x为红色的情况"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">    x.red = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（三）待删除的节点y为黑色，用后继节点x替换，且x为黑色。删除y之后，x相对于xpr的子树就少了一个黑色节点，需要进行调整。且情况分为以下四种：【注】图中只是树的一部分，x要比xpr少一个黑色子节点。</p>
<p>（1）x的兄弟xpr是红色的。对于这种情况，xpr变为黑色，xp变为红色，对xp左旋。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4641605893048654080.jpg"></p>
<p>（2）x的兄弟xpr是黑色的，且xpr的俩个孩子都是黑色的。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8390039386922256530.jpg"></p>
<p>（3）x的兄弟xpr是黑色的，xpr左孩子红色，右孩子黑色。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/5891667748188383744.jpg"></p>
<p>（4）x的兄弟xpr是黑色的，xpr的右孩子为红色。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8185952396087129951.jpg"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">        xpr.red = <span class="keyword">false</span>;</span><br><span class="line">        xp.red = <span class="keyword">true</span>;</span><br><span class="line">        root = rotateLeft(root, xp);</span><br><span class="line">        xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">        x = xp;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        RedBlackTree sl = xpr.left, sr = xpr.right;</span><br><span class="line">        <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp; (sl == <span class="keyword">null</span> || !sl.red)) &#123;            </span><br><span class="line">            xpr.red = <span class="keyword">true</span>;</span><br><span class="line">            x = xp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateRight(root, xpr);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">            &#125;</span><br><span class="line">            x = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上删除操作是默认x为左节点，右节点的情况同理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>1.每个节点只能是黑色或者红色。<br>2.根节点为黑色。<br>3.红色节点的儿子必须都是黑色。<br>4.对每个节点，从该节点到其子孙节点的所有路径上包含相同数目的黑节点（黑色平衡）。</p>
</blockquote>
<p>回顾一下红黑树的重要性质，下面讨论红黑树的删除操作。<br>红黑树的删除同样是按照二叉查找树的方式查找待删除节点，之后需要考虑在不违反以上性质的情况下删除该节点。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="数据结构" scheme="http://ningquec.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://ningquec.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sed命令详解]]></title>
    <link href="http://ningquec.github.io/2015/07/02/LinuxCommandSed/"/>
    <id>http://ningquec.github.io/2015/07/02/LinuxCommandSed/</id>
    <published>2015-07-02T10:51:48.000Z</published>
    <updated>2015-07-02T10:56:44.217Z</updated>
    <content type="html"><![CDATA[<h2 id="一、简介">一、简介</h2><p>sed命令是一个很强大的文本编辑器，可以对来自文件、以及标准输入的文本进行编辑。</p>
<p>执行时，sed会从文件或者标准输入中读取一行，将其复制到缓冲区，对文本编辑完成之后，读取下一行直到所有的文本行都编辑完毕。<br>所以sed命令处理时只会改变缓冲区中文本的副本，如果想要直接编辑原文件，可以使用-i选项或者将结果重定向到新的文件中。</p>
<p>sed命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [options] commands [inputfile...]</span><br></pre></td></tr></table></figure></p>
<p>options表示sed命令的一些选项，常见的选项如下表：<br><a id="more"></a></p>
<p><table><tr><th>选项名</th><th>作用</th></tr><tr><td>-n</td><td>取消默认输出</td></tr><tr><td>-e</td><td>多点编辑，可移执行多个子命令</td></tr><tr><td>-f</td><td>从脚本文件中读取命令（sed操作可以事先写入脚本，然后通过-f读取并执行）</td></tr><tr><td>-i</td><td>直接编辑原文件</td></tr><tr><td>-l</td><td>指定行的长度</td></tr><tr><td>-r</td><td>在脚本中使用扩展表达式</td></tr></table></p>
<h2 id="二、应用场景">二、应用场景</h2><p>sed命令比较适用于大的文本文件，用普通文本编辑器难以胜任的情况。下面分别介绍直接打印、插入、删除、替换等编辑操作。<br>&nbsp;&nbsp;&nbsp;实验用文件内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#===================test1.txt======================&#10;letitia&#10;mail&#10;uuencode&#10;1003605091&#10;01566</span><br></pre></td></tr></table></figure></p>
<p>（1）行打印，输出缓冲区内容，使用sed的<code>p子命令</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;1,3 p&#39; test1.txt&#10;echo &#34;=====================&#34;&#10;sed -n &#39;1,3 p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;letitia&#10;mail&#10;mail&#10;uuencode&#10;uuencode&#10;1003605091&#10;01566&#10;=====================&#10;letitia&#10;mail&#10;uuencode</span><br></pre></td></tr></table></figure></p>
<p>p子命令代表print，可以打印出sed缓冲区内的内容。<br>sed命令中，直接采用数字代表某个特定的文本行：<code>&#39;1 p&#39;</code>代表打印第一行；<code>&#39;1,3 p&#39;</code>代表打印1到3行；特别的，最后一行的行号为$。</p>
<p>观察输出结果，不使用-n选项时，sed命令把1到3行输出了两次。这是因为不使用-n时，sed首先读取一行，并默认将缓冲区内的文本输出出来，之后p子命令再次输出。使用-n时，默认输出取消，只有p子命令的输出结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;/^ma/,5 p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;mail&#10;uuencode&#10;1003605091&#10;01566</span><br></pre></td></tr></table></figure></p>
<p>sed命令支持正则表达式定位。语法为<code>/re/</code>，re表示正则表达式。<br>本例表示打印出从匹配正则表达式的地方到第5行，也就是从匹配以ma开头的文本行处开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;1~2 p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;uuencode&#10;01566</span><br></pre></td></tr></table></figure></p>
<p><code>1~2</code>表示从第一行开始，行号递增2输出，即输出奇数行。语法格式为<code>first~step</code>。<br>（2）插入文本行，追加文本行<br>这两种情况很类似。插入文本使用<code>i子命令</code>，表示在指定位置前面插入文本；追加文本使用<code>a子命令</code>，表示在指定位置之后插入文本。观察一下两个的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;2 i insert&#39; -e &#39;1,4 p&#39; test1.txt &#10;&#10;#-e&#36873;&#39033;&#34920;&#31034;&#22810;&#20010;&#23376;&#21629;&#20196;&#65292;&#26412;&#20363;&#25191;&#34892;i&#23376;&#21629;&#20196;&#20043;&#21518;&#25191;&#34892;&#20102;p&#23376;&#21629;&#20196;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;insert&#10;mail&#10;uuencode&#10;1003605091</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;2 a insert&#39; -e &#39;1,4 p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;mail&#10;insert&#10;uuencode&#10;1003605091</span><br></pre></td></tr></table></figure>
<p>（3）删除文本行，使用<code>d子命令</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;2 d&#39; -e &#39;1,$ p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;uuencode&#10;1003605091&#10;01566</span><br></pre></td></tr></table></figure></p>
<p>（4）替换文本行，使用<code>c子命令</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;2 c newmail&#39; -e &#39;1,$ p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;newmail&#10;uuencode&#10;1003605091&#10;01566</span><br></pre></td></tr></table></figure></p>
<p>【注】以上均未使用-i选项，所以更改的只是副本。<br><b>（5）替换指定文本，使用<code>s子命令</code></b><br>这一个命令实用性很广，并且灵活。语法也比之上面特别一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;&#20301;&#32622;&#21442;&#25968; s/pattern/replaced/[flag]&#39;</span><br></pre></td></tr></table></figure></p>
<p>pattern为要替换的文本，支持正则表达式，replaced表示用来替换的一般字符串（不支持正则表达式）。<br>flag是替换标志，用来影响匹配替换的规则：</p>
<p><table><tr><th>flag</th><th>用法</th></tr><tr><td>g</td><td>全局匹配，会替换文本行中所有匹配的字符串</td></tr><tr><td>十进制n</td><td>替换文本行中第n个匹配的字符串</td></tr><tr><td>p</td><td>替换第一个匹配的字符串，并且将缓冲区输出到标准输出</td></tr><tr><td>w</td><td>替换第一个匹配的字符串，并且将改动的行输出到磁盘文件中</td></tr><tr><td>缺省</td><td>替换第一个匹配的字符串</td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;s/[0-9]\&#123;10\&#125;/miss letitia/g&#39; -e &#39;1,$ p&#39; test1.txt&#10;#&#123;&#125;&#35201;&#36716;&#20041;&#65292;&#22240;&#20026;&#27492;&#22788;&#20351;&#29992;&#30340;&#19981;&#26159;&#25193;&#23637;&#27491;&#21017;&#34920;&#36798;&#24335;&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;mail&#10;uuencode&#10;miss letitia&#10;01566</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;1,/^ma/ s/l/L/g&#39; -e &#39;1,$ p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;Letitia&#10;maiL&#10;uuencode&#10;miss letitia&#10;01566&#10;#&#21487;&#20197;&#30475;&#21040;&#65292;&#26412;&#20363;&#23558;&#21069;&#20004;&#34892;&#37324;&#30340;l&#26367;&#25442;&#20026;L&#12290;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;1,3&#123;&#10;            s/l/L/g&#10;            s/e/E/g&#10;            2 i tyrone&#10;            p&#10;            &#125;&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;LEtitia&#10;tyrone&#10;maiL&#10;uuEncodE</span><br></pre></td></tr></table></figure>
<p>最后这个例子比较复杂。使用大括号，表示对1到3行做了一组操作。</p>
<h2 id="三、其他的小事">三、其他的小事</h2><ul>
<li><p>以上都是采用了文件输入做实验，也可以采用其他方式，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#34;s/letitia/hello world/g&#34; `grep &#34;letitia&#34; -rl test1.txt`&#10;#&#23558;grep&#30340;&#32467;&#26524;&#20316;&#20026;&#36755;&#20837;&#65292;&#27880;&#24847;&#35201;&#29992;&#21453;&#24341;&#21495;&#25324;&#36215;&#26469;&#65292;&#23558;&#25324;&#21495;&#20869;&#37096;&#20998;&#35299;&#37322;&#20026;linux&#21629;&#20196;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当用户的编辑操作比较复杂时，建议使用sed脚本文件。</p>
</li>
<li>同正则表达式一样，匹配元字符时要用转义。使用基本正则表达式时，{}等也要转义。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、简介">一、简介</h2><p>sed命令是一个很强大的文本编辑器，可以对来自文件、以及标准输入的文本进行编辑。</p>
<p>执行时，sed会从文件或者标准输入中读取一行，将其复制到缓冲区，对文本编辑完成之后，读取下一行直到所有的文本行都编辑完毕。<br>所以sed命令处理时只会改变缓冲区中文本的副本，如果想要直接编辑原文件，可以使用-i选项或者将结果重定向到新的文件中。</p>
<p>sed命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [options] commands [inputfile...]</span><br></pre></td></tr></table></figure></p>
<p>options表示sed命令的一些选项，常见的选项如下表：<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树（二）：红黑树]]></title>
    <link href="http://ningquec.github.io/2015/06/30/DataStructureRBT/"/>
    <id>http://ningquec.github.io/2015/06/30/DataStructureRBT/</id>
    <published>2015-06-30T12:45:05.000Z</published>
    <updated>2015-07-07T13:32:58.913Z</updated>
    <content type="html"><![CDATA[<h2 id="一、简介">一、简介</h2><p>上一篇中介绍了二叉查找树的特性，其中提到二叉查找树查找插入操作的时间复杂度约是O(log_2n)，但这只是在最优状态下。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4310693094167885900.jpg?imageView2/0/w/300/h/250" alt="二叉查找树退化为斜树"><br>所以我们希望得到一棵基本维持平衡的二叉查找树，在最坏的情况下时间复杂度也能达到O(log_2n)。于是红黑树应运而生。</p>
<p>红黑树是这样的一种二叉查找树（是的，它满足二叉查找树的所有性质）：每个节点都含有5个域，包括指向左右孩子的指针、指向父节点的指针、数据域和颜色。如果相应的指针为空设为NIL。同时符合以下4大性质：<br><a id="more"></a></p>
<blockquote>
<p>1.每个节点只能是黑色或者红色。<br>2.根节点为黑色。<br>3.红色节点的儿子必须都是黑色。<br>4.对每个节点，从该节点到其子孙节点的所有路径上包含相同数目的黑节点（黑色平衡）。</p>
</blockquote>
<p>这样的目的是什么呢？见下图<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/13124250-82a6750fab4343a28f78de1aaca37bae.jpg" alt="红黑树"><br>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长（可以反证）。所以红黑树大致上能够保持平衡。</p>
<h2 id="二、红黑树的建立">二、红黑树的建立</h2><p>下面开始建立一棵红黑树。红黑树的基本数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span> </span>&#123;</span><br><span class="line">	RedBlackTree parent;</span><br><span class="line">	RedBlackTree left;</span><br><span class="line">	RedBlackTree right;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">boolean</span> red;</span><br><span class="line">	RedBlackTree(<span class="keyword">int</span> val, RedBlackTree parent, RedBlackTree left, RedBlackTree right, <span class="keyword">boolean</span> red)&#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">		<span class="keyword">this</span>.parent = parent;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">		<span class="keyword">this</span>.red = red;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>红黑树的插入操作同二叉查找树基本相同，只是要多考虑颜色的因素。插入时，总是插入红色的节点，这样可以尽量的保持完美黑色平衡。<br>同时也可能会出现不符合4大性质的情况，所以需要在插入后对树进行动态调整。<br>也就是说，我们先按照二叉查找树的方式插入红色节点，之后进行树的调整操作。<br>基本思想是把出现违背红黑树性质的结点向上移，如果能移到根结点，那么很容易就能通过直接修改根结点来恢复红黑树的性质。</p>
<p>调整涉及左旋和右旋两种操作，如图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/2981960730598275566.jpg?imageView2/0/w/400/h/300" alt="左旋图示"><br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8845355295264617830.jpg?imageView2/0/w/400/h/300" alt="右旋图示"><br>对pivot左旋：</p>
<ol>
<li>y = pivot.right。pivot的右孩子为y</li>
<li>privt.right = y.left, y.parent = x.parent。把y的左孩子作为pivot的右孩子，y取代pivot的位置</li>
<li>y.left = privt。把pivot作为y的左孩子。</li>
</ol>
<p>这样做不会改变树的排序性质，但是可能破坏了颜色性质，调整往往需要和重新涂色一起进行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RedBlackTree <span class="title">rotateLeft</span><span class="params">(RedBlackTree root, RedBlackTree pivot)</span></span>&#123;</span><br><span class="line">	RedBlackTree y,yl,yp;</span><br><span class="line">	<span class="keyword">if</span>(pivot != <span class="keyword">null</span> &amp;&amp; (y = pivot.right) != <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>((yl = pivot.right = y.left) != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//把y的左孩子yl作为pivot的右孩子</span></span><br><span class="line">			yl.parent = pivot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((yp = y.parent = pivot.parent) == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//如果y的parent为空，说明它是root节点，涂黑</span></span><br><span class="line">			(root = y).red =<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(yp.left == pivot)&#123;</span><br><span class="line">			yp.left = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			yp.right = y;</span><br><span class="line">		&#125;</span><br><span class="line">		y.left = pivot;</span><br><span class="line">		pivot.parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>右旋同理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RedBlackTree <span class="title">rotateRight</span><span class="params">(RedBlackTree root, RedBlackTree pivot)</span></span>&#123;</span><br><span class="line">	RedBlackTree y,yr,yp;</span><br><span class="line">	<span class="keyword">if</span>(pivot != <span class="keyword">null</span> &amp;&amp; (y = pivot.left) != <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>((yr = pivot.left = y.right) != <span class="keyword">null</span>)&#123;</span><br><span class="line">			yr.parent = pivot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((yp = y.parent = pivot.parent) == <span class="keyword">null</span>)&#123;</span><br><span class="line">			(root = y).red = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(yp.right == pivot)&#123;</span><br><span class="line">			yp.right = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			yp.left = y;</span><br><span class="line">		&#125;</span><br><span class="line">		y.right = pivot;</span><br><span class="line">		pivot.parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面分情况讨论插入节点操作：<br>约定几个变量先：x为需调整节点，xp为x的父节点，xpp为xp的父节点，xppl为xpp的左孩子。。类推。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4696169845330901090.jpg?imageView2/0/w/400/h/300" alt="变量图示"><br>（1）需调整节点x的父节点xp为空，即需调整节点为根节点，直接将颜色设为黑色。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    x.red = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）需调整节点x的父节点为黑色，或者x的父节点为根节点，不需调整。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(xp = x.parent).red || (xpp = xp.parent) ==<span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）需调整节点x的父节点xp为红色且xp为xpp的左孩子，叔叔节点（xpp.right）也是红色。<br>这种情况将x的父节点xp和叔叔节点xppr变为黑色，然后将xpp变为红色，然后将xpp作为新的节点x进行调整。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/7987311314941575918.jpg?imageView2/0/w/400/h/300"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">        xppr.red = <span class="keyword">false</span>;</span><br><span class="line">        xp.red = <span class="keyword">false</span>;</span><br><span class="line">        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">        x = xpp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（4）需调整节点x的父节点xp是红色且xp为xpp的左孩子,叔叔节点是黑色，当前节点是其父节点的右孩子。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8071829641948021744.jpg?imageView2/0/w/400/h/300"><br>这种情况在xp节点处左旋。rotateLeft(root, xp),将xp作为新的节点x进行调整。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == xp.right &amp;&amp; xp == (xppl = xpp.left) &amp;&amp; !xppr.red) &#123;</span><br><span class="line">    root = rotateLeft(root, x = xp);</span><br><span class="line">    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（5）需调整节点x的父节点xp是红色且xp为xpp的左孩子,叔叔节点是黑色，当前节点是其父节点的左孩子。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/2574947212204924184.jpg?imageView2/0/w/400/h/300"><br>这种情况父节点xp变为黑色，祖父节点xpp变为红色，在祖父节点处右旋。rotateRight(root, xpp)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xp != <span class="keyword">null</span> &amp;&amp; xp == (xppl = xpp.left) &amp;&amp; !xppr.red) &#123;</span><br><span class="line">    xp.red = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">        root = rotateRight(root, xpp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总的插入方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RedBlackTree <span class="title">balanceInsertion</span><span class="params">(RedBlackTree root, TRedBlackTree x)</span> </span>&#123;</span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (RedBlackTree xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                root = rotateLeft(root, x = xp);</span><br><span class="line">                xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//初始xp为xpp右孩子的情况</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、下篇">三、下篇</h2><p>红黑树的删除</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、简介">一、简介</h2><p>上一篇中介绍了二叉查找树的特性，其中提到二叉查找树查找插入操作的时间复杂度约是O(log_2n)，但这只是在最优状态下。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4310693094167885900.jpg?imageView2/0/w/300/h/250" alt="二叉查找树退化为斜树"><br>所以我们希望得到一棵基本维持平衡的二叉查找树，在最坏的情况下时间复杂度也能达到O(log_2n)。于是红黑树应运而生。</p>
<p>红黑树是这样的一种二叉查找树（是的，它满足二叉查找树的所有性质）：每个节点都含有5个域，包括指向左右孩子的指针、指向父节点的指针、数据域和颜色。如果相应的指针为空设为NIL。同时符合以下4大性质：<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="数据结构" scheme="http://ningquec.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://ningquec.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[目录树的java实现以及Stack类的一些细节]]></title>
    <link href="http://ningquec.github.io/2015/06/27/FileTreeInJava/"/>
    <id>http://ningquec.github.io/2015/06/27/FileTreeInJava/</id>
    <published>2015-06-27T08:58:57.000Z</published>
    <updated>2015-07-07T13:24:33.961Z</updated>
    <content type="html"><![CDATA[<p>使用Linux里的tree命令输出目录结构，就是下面这样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500; CNAME&#10;&#9492; _posts&#10;&#12288; &#9500; CommandFind.md&#10;&#12288; &#9500; CommandFind2.md&#10;&#12288; &#9500; CommandGrep.md&#10;&#12288; &#9500; ConcurrentHashMap.md&#10;&#12288; &#9500; DataStructureBST.md&#10;&#12288; &#9500; FileTreeInJava.md&#10;&#12288; &#9500; Grep&#38;RE.md&#10;&#12288; &#9492; HashTable&#38;BloomFilter.md</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>很炫酷，所以去找了一个java版本并学习了一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTreeTest</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileTree tree = <span class="keyword">new</span> FileTree(<span class="string">"G:/blogs/source"</span>);</span><br><span class="line">        tree.generateFileTree();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTree</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> File root;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileTree</span><span class="params">(File root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileTree</span><span class="params">(String rootName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//传入字符串作为路径</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> File(rootName));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateFileTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Stack &lt;Boolean&gt; stack = <span class="keyword">new</span> Stack &lt;Boolean&gt;();</span><br><span class="line">		tree(root , <span class="number">0</span> , stack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tree</span><span class="params">(File dir , <span class="keyword">int</span> level, Stack&lt;Boolean&gt; stack)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//递归函数</span></span><br><span class="line">		<span class="keyword">if</span>(dir == <span class="keyword">null</span> || !dir.exists())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		print(dir,level,stack);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果是文件，返回；如果是目录，递归。</span></span><br><span class="line">		<span class="keyword">if</span>(dir.isFile())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		File [] childOfDir = dir.listFiles();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childOfDir.length; i++)&#123;</span><br><span class="line">			stack.push( i == childOfDir.length - <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//标记每一个目录下的最后一个文件，因为目录树的符号不同</span></span><br><span class="line">			tree(childOfDir[i],level + <span class="number">1</span>, stack);</span><br><span class="line">			stack.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(File dir, <span class="keyword">int</span> level, Stack&lt;Boolean&gt; stack)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , k = stack.size() - <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            System.out.print(stack.get(i) ? <span class="string">"　 "</span> : <span class="string">"│ "</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(level &gt; <span class="number">0</span>) &#123;            </span><br><span class="line">            System.out.print(stack.get(stack.size() - <span class="number">1</span>) ? <span class="string">"└ "</span> : <span class="string">"├ "</span>);</span><br><span class="line">            <span class="comment">//如果是该目录下的最后一个，打印一个"└ "，否则打印"├ "</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(level == <span class="number">0</span> ? dir.getPath() : dir.getName()); </span><br><span class="line">        <span class="comment">//如果是根目录，打印出完整路径，否则只打印名字	</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码是引自<a href="http://bbs.csdn.net/topics/370068354" target="_blank" rel="external">CSDN论坛</a>。基本算法思想就是递归：访问目标路径，如果遇到一个文件，直接打印；遇到目录就先打印出来，然后将该目录作为目标路径。</p>
<hr>
<p>之后的问题就出在引用的java集合类上。Bruce大神曾经说过，不要用古老的Stack类，我一开始采用LinkedList来代替Stack，打印会出现以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\blogs\source&#10;&#9500; CNAME&#10;&#9492; _posts&#10;&#9474; &#9492; CommandFind.md&#10;&#9474; &#9492; CommandFind2.md&#10;&#9474; &#9492; CommandGrep.md&#10;&#9474; &#9492; ConcurrentHashMap.md&#10;&#9474; &#9492; DataStructureBST.md&#10;&#9474; &#9492; FileTreeInJava.md&#10;&#9474; &#9492; Grep&#38;RE.md&#10;&#12288; &#9492; HashTable&#38;BloomFilter.md</span><br></pre></td></tr></table></figure></p>
<p>树变成了这样半身不遂的样子。我查看了这两个集合类的源代码，发现了其中的问题。原来是这两种存储方式的顺序不同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stack类的push()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    addElement(item);</span><br><span class="line">    <span class="comment">//该方法加了synchronized，定义在Vector中</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedList的push()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//初始化newNode，前驱节点为空，后继节点为f</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;  <span class="comment">//已从结构上修改此列表的次数，定义在AbstractList中，初值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，Stack类采用数组实现，push()方法将新元素加在了数组末端：<code>elementData[elementCount++] = obj</code>；<br>LinkedList是链表实现，push()方法采用了头插法。简单测试如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStack</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">		Stack &lt;Integer&gt; stack = <span class="keyword">new</span> Stack &lt;Integer&gt;();</span><br><span class="line">		LinkedList &lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">			stack.push(i);</span><br><span class="line">			list.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(stack);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(stack.get(<span class="number">1</span>));</span><br><span class="line">		System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>所以目录树半身不遂的根源就是由于集合类内部的不同，导致get()方法的结果不同：<code>System.out.print(stack.get(i) ? &quot;　 &quot; : &quot;│ &quot;);</code><br><code>System.out.print(stack.get(stack.size() - 1) ? &quot;└ &quot; : &quot;├ &quot;);</code>。</p>
<p>真相大白。</p>
<p>可是为什么现在要放弃Stack类，选择使用LinedList类呢？Bruce在Java编程思想中说：</p>
<blockquote>
<p>首先，Stack（堆栈）是从Vector 继承来的，亦即Stack“是”一个Vector，这种说法是不确切的。其次，对于Vector 许多重要的方法，如addElement()以及elementAt()等，它们都变成了synchronized（同步的）。这会造成显著的性能开销，可能会把final提供的性能改善抵销得一干二净。因此，程序员不得不猜测到底应该在哪里进行优化。在标准库里居然采用了如此笨拙的设计，真不敢想象会在程序员里引发什么样的情绪。</p>
</blockquote>
<p>也就是说，Stack继承自Vector，显然就像是在说：栈是一个向量！这是说不通的，Stack的继承并不是一种类型的继承（例如企鹅继承鸟类，企鹅是鸟的一个类型），而只是实现上的一个继承罢了。<br>其次，Vector里的名字也被吐槽：addElement()。。。为什么不用add()呢？<br>还有Stack会继承Vector里很多并不需要的方法：比如public void add(int index, E element)，这只会破坏Stack后进先出的规则。<br>最重要的就是性能问题。Vector是线程同步的，所以Stack里的很多方法都会有明显的同步开销，如果面对多线程的环境，最好使用java.util.concurrent包下的类，比如java.util.concurrent.ConcurrentLinkedQueue。</p>
<p>这一双父子，Vector类和Stack类，都要被丢到故纸堆去了。</p>
<p>顺便插一句，final方法性能会改善是因为</p>
<blockquote>
<p>将一个方法设成final 后，编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。只要编译器发现一个final 方法调用，就会（根据它自己的判断）忽略为执行方法调用机制而采取的常规代码插入方法（将自变量压入堆栈；跳至方法代码并执行它；跳回来；清除堆栈自变量；最后对返回值进行处理）。相反，它会用方法主体内实际代码的一个副本来替换方法调用。这样做可避免方法调用时的系统开销。当然，若方法体积太大，那么程序也会变得雍肿，可能受到到不到嵌入代码所带来的任何性能提升。因为任何提升都被花在方法内部的时间抵消了。Java 编译器能自动侦测这些情况，并颇为“明智”地决定是否嵌入一个final 方法。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用Linux里的tree命令输出目录结构，就是下面这样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500; CNAME&#10;&#9492; _posts&#10;&#12288; &#9500; CommandFind.md&#10;&#12288; &#9500; CommandFind2.md&#10;&#12288; &#9500; CommandGrep.md&#10;&#12288; &#9500; ConcurrentHashMap.md&#10;&#12288; &#9500; DataStructureBST.md&#10;&#12288; &#9500; FileTreeInJava.md&#10;&#12288; &#9500; Grep&#38;RE.md&#10;&#12288; &#9492; HashTable&#38;BloomFilter.md</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="集合类" scheme="http://ningquec.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[grep与正则表达式]]></title>
    <link href="http://ningquec.github.io/2015/06/26/Grep&RE/"/>
    <id>http://ningquec.github.io/2015/06/26/Grep&RE/</id>
    <published>2015-06-26T12:22:58.000Z</published>
    <updated>2015-07-22T07:46:21.152Z</updated>
    <content type="html"><![CDATA[<p><a href="http://tyroneli.com/2015/06/16/grep-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">上回</a>说到grep与正则表达式关系紧密，今天来详细的谈一谈。</p>
<h2 id="一、简介">一、简介</h2><p>正则表达式，让人不明觉厉，望而却步。但实际上它就相当于数学里的九九乘法表，背会很难，之后做乘法就很快了。<br>正则表达式也是这样的工具，看起来很难，背会了之后大有帮助。乘法表建立了乘法的基础规则，而正则表达式建立了一系列语法的规则。它是用来匹配符合某种语法的字符串，从而可以对这些筛选出来的字符串进行处理。</p>
<p>所以天然的，在Linux中，grep命令经常与正则表达式结合起来执行一些模糊查询或者指向性查询。<br>比如一些常见的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll | grep -E &#34;*.txt&#34;  &#10;    #&#21015;&#20986;&#24403;&#21069;&#36335;&#24452;&#19979;&#30340;txt&#25991;&#20214;&#10;    #-E&#36873;&#39033;&#34920;&#31034;&#20351;&#29992;&#25193;&#23637;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#65292;grep -E&#30456;&#24403;&#20110;egrep&#10;    #&#34;*&#34;&#23601;&#26159;&#19968;&#31181;&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#20803;&#23383;&#31526;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>【注】其实直接使用<code>ll *.txt</code>也能得到相同结果，这是因为Linux直接把*解释为任意的字符串。</p>
<h2 id="二、正则表达式基础">二、正则表达式基础</h2><p>正则表达式是如何建立语法规则的呢？它定义了一系列的元字符（像”*“这样的），通过元字符和其他字符的组合来表达出一种规则，对待匹配文本进行筛选，只有符合这种规则的文本才能被保留下来。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8028807454817125924.jpg" alt="筛选过程"></p>
<ul>
<li>基本正则表达式所定义的元字符</li>
</ul>
<table><tr><th>元字符</th><th>作用</th><th>例子</th><th>例子说明</th></tr><tr><td>^</td><td>行首定位符</td><td>^ty</td><td>匹配”t”开头，后面紧跟一个”y”的字符串</td></tr><tr><td>$</td><td>行尾定位符</td><td>txt$</td><td>匹配以”t”结尾，前面两个字符是”t””x”的字符串</td></tr><tr><td>.</td><td>单个字符匹配</td><td>s.</td><td>匹配”s”后面有一个字符的字符串</td></tr><tr><td>*</td><td>限定符</td><td>s*</td><td>“*“表示匹配其前导字符若干次，包括0次。这里是匹配有若干个”s”的字符串</td></tr><tr><td>[]</td><td>字符集匹配</td><td>[abc]</td><td>表示匹配”a”,”b”或”c”的字符串</td></tr><tr><td>[^]</td><td>字符集不匹配</td><td>[^abc]</td><td>表示不匹配”a”,”b”,”c”里的任意字符</td></tr><tr><td>()</td><td>子表达式</td><td>([0-9]{2})?</td><td>匹配两个或0个数字</td></tr><tr><td>x{m,n}</td><td>区间表达式</td><td>a{2,3}</td><td>表示”a”重复2~3次</td></tr></table>

<ul>
<li>扩展正则表达式的元字符</li>
</ul>
<table><tr><th>元字符</th><th>作用</th><th>例子</th><th>例子说明</th></tr><tr><td>+</td><td>限定符，同*</td><td>s+</td><td>“+”表示匹配其前导字符若干次，至少1次</td></tr><tr><td>?</td><td>限定符</td><td>ss?</td><td>“?”表示前面的字符可以重复0或1次。这里是一个”s”后面可能再跟一个”s”</td></tr><tr><td>(|)</td><td>括号竖线组合使用表示可选值</td><td>(a|^ym)</td><td>匹配含有”a”或者以”ym”开头的字符串</td></tr></table>


<ul>
<li>POSIX字符集</li>
</ul>
<p>不同国家的字符编码很有可能不同，例如：<br>LANG=C：A B C D … Z a b c d …z<br>LANG=zh_TW：a A b B c C d D … z Z<br>当采用第二种编码时，[A-Z]之间会包括小写字母b-z。所以为了避免这种问题，可以使用POSIX字符集来使用特定的字符类。</p>
<p><table><tr><th>字符类</th><th>说明</th></tr><tr><td>[:alnum:]</td><td>匹配任意一个字母或者数字，等价于A-Za-z0-9</td></tr><tr><td>[:alpha:]</td><td>匹配任意一个字母，等价于A-Za-z</td></tr><tr><td>[:digit:]</td><td>匹配任意一个数字，等价于0-9</td></tr><tr><td>[:lower:]</td><td>匹配小写字母，等价于a-z</td></tr><tr><td>[:upper:]</td><td>匹配大写字母，等价于A-Z</td></tr><tr><td>[:graph:]</td><td>匹配一个看的见的字符，不包括空白字符</td></tr><tr><td>[:print:]</td><td>匹配一个可以打印的字符</td></tr><tr><td>[:blank:]</td><td>匹配空格和tab</td></tr><tr><td>[:space:]</td><td>匹配一个空白字符，包括空格、tab、换行、分页符</td></tr><tr><td>[:punct:]</td><td>匹配一个标点符号</td></tr><tr><td>[:xdigit:]</td><td>匹配一个十六进制数字，即0-9,a-f,A-F</td></tr></table><br>【注意】这些字符类要放在方括号中，才能表示字符集匹配：[[:alnum:]] = [A-Za-z0-9]</p>
<h2 id="三、grep与正则表达式的例子">三、grep与正则表达式的例子</h2><p>(1)简单匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#21305;&#37197;&#31354;&#34892;&#10;egrep &#34;^$&#34; testfile    &#10;&#10;#&#21305;&#37197;&#25152;&#26377;&#33521;&#25991;&#23383;&#31526;&#10;egrep &#34;[a-zA-Z]&#34; testfile&#10;&#10;#&#21305;&#37197;tast&#25110;&#32773;test&#10;egrep &#34;t[ae]st&#34; testfile</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#21305;&#37197;&#20197;&#23383;&#31526;s&#24320;&#22836;&#65292;&#32039;&#36319;&#33509;&#24178;b&#30340;&#25991;&#20214;&#21517;&#10;ll | egrep &#34;^sb*&#34;&#10;&#10;#&#21305;&#37197;txt&#25991;&#20214;&#10;ll | egrep &#34;\.txt$&#34;      #&#36825;&#37324;&#30340;&#34;.&#34;&#38656;&#35201;&#36827;&#34892;&#36716;&#20041;</span><br></pre></td></tr></table></figure>
<p>(2)复杂一些的匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#21305;&#37197;QQ&#21495;&#30721;&#65292;&#31532;&#19968;&#20301;&#19981;&#33021;&#26159;0&#65292;5&#20301;&#20197;&#19978;&#30340;&#25968;&#23383;&#12290;&#10;egrep &#34;[1-9][0-9]&#123;4,&#125;&#34; testfile&#10;&#10;#&#21305;&#37197;IP&#22320;&#22336;&#65292;&#20849;4&#32452;&#25968;&#23383;&#65292;&#29992;&#34;.&#34;&#38548;&#24320;&#10;egrep &#34;^([0-9]&#123;1,2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\.   #&#31532;&#19968;&#32452;&#25968;&#23383;&#10;        ([0-9]&#123;1,2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\.   #&#31532;&#20108;&#32452;&#25968;&#23383;&#10;        ([0-9]&#123;1,2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\.   #&#31532;&#19977;&#32452;&#25968;&#23383;&#10;        ([0-9]&#123;1,2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])$&#34;   #&#31532;&#22235;&#32452;&#25968;&#23383;&#10;        testfile &#10;&#10;#&#21305;&#37197;&#37038;&#31665;&#22320;&#22336;&#10;egrep &#34;^[a-z0-9]([a-z0-9]*[-_]?[a-z0-9]+)*@&#10;       ([a-z0-9]*[-_]?[a-z0-9]+)+[.][a-z]&#123;2,3&#125;([.][a-z]&#123;2&#125;)?$&#34;</span><br></pre></td></tr></table></figure></p>
<p><code>此处注意：</code>区间表达式{}应该写成”\{\}”表示转义，实验中发现加不加”\“转义都能得出正确结果，但是直接使用基本正则表达式（grep不加-E选项）则不行。所以应该是扩展正则表达式中取消了这个需要转义字符的地方。</p>
<h2 id="四、其他">四、其他</h2><p>琐碎的片段：</p>
<ol>
<li>当需要将元字符当作普通字符匹配的时候，需要转移字符”\“，但是当元字符位于”[]”中时，除了”-“或者”^”极少数元字符以外，其它的自动转义为普通字符。</li>
<li>正则表达式从左到右计算，遵循一定的优先级：转义符”\“ &gt; 方括号”[]” &gt; 分组 “()” &gt; 限定符”*,+,?,{}” &gt; 普通字符 &gt; 定位符”^,$” &gt; 或”|”。</li>
<li>匹配同一种字符可能有多种正则表达式的写法。</li>
<li>shell本身不支持正则表达式，但是支持”*”，”?”等通配符。</li>
<li>支持正则表达式的还有sed命令，awk命令。以后可以详述。</li>
<li><b>参考</b>：<br>shell从入门到精通，张春晓等编著；<br><a href="http://linux.vbird.org/linux_basic/0330regularex.php#basic_regexp_char" target="_blank" rel="external">鸟哥的Linux私房菜</a>。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://tyroneli.com/2015/06/16/grep-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">上回</a>说到grep与正则表达式关系紧密，今天来详细的谈一谈。</p>
<h2 id="一、简介">一、简介</h2><p>正则表达式，让人不明觉厉，望而却步。但实际上它就相当于数学里的九九乘法表，背会很难，之后做乘法就很快了。<br>正则表达式也是这样的工具，看起来很难，背会了之后大有帮助。乘法表建立了乘法的基础规则，而正则表达式建立了一系列语法的规则。它是用来匹配符合某种语法的字符串，从而可以对这些筛选出来的字符串进行处理。</p>
<p>所以天然的，在Linux中，grep命令经常与正则表达式结合起来执行一些模糊查询或者指向性查询。<br>比如一些常见的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll | grep -E &#34;*.txt&#34;  &#10;    #&#21015;&#20986;&#24403;&#21069;&#36335;&#24452;&#19979;&#30340;txt&#25991;&#20214;&#10;    #-E&#36873;&#39033;&#34920;&#31034;&#20351;&#29992;&#25193;&#23637;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#65292;grep -E&#30456;&#24403;&#20110;egrep&#10;    #&#34;*&#34;&#23601;&#26159;&#19968;&#31181;&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#20803;&#23383;&#31526;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
      <category term="正则表达式" scheme="http://ningquec.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树（一）：二叉查找树]]></title>
    <link href="http://ningquec.github.io/2015/06/22/DataStructureBST/"/>
    <id>http://ningquec.github.io/2015/06/22/DataStructureBST/</id>
    <published>2015-06-22T07:28:51.000Z</published>
    <updated>2015-07-07T13:45:33.956Z</updated>
    <content type="html"><![CDATA[<h2 id="一、二叉查找树的基本特点">一、二叉查找树的基本特点</h2><blockquote>
<p>二叉查找树的定义：二叉查找树（BST，又叫二叉排序树）是一棵二叉树，其中每一个节点都包含两个指向两个孩子的指针域和一个实现了comparable接口的数据域。并且，每个节点都大于其左子树任意节点，小于右子树中的任意节点。</p>
</blockquote>
<p>抄书完毕，那么为什要建立这样的一个数据结构呢？</p>
<p>玩一个猜数字的游戏，1~64之间（假设目标数字为20）。<br>“1”  “低了”  “2”  “低了”  “3”  “低了”  “4” “低了”……     锲而不舍型要猜上20次。<br>“32”  “高了”  “16”  “低了”  “24”  “高了”  “20”  “答对了”     机智折半型只需要猜4次。<br>无论目标数字如何刁钻，采用折半的策略都能在log_2n次以内猜中。<br>因为这样每一次都能够排除掉一半的可能性，也就是说折半策略每一次都将问题的解空间折半。<br><a id="more"></a><br>把基于比较的排序算法换个角度思考：一串个数为N的数字，排序方式共有N!种，要从中找到唯一的目标序列。<br>同样的，我们把排序的解空间折半:在比较了某两个数字之后立即排除掉一半的排序方式。<br>找到目标序列的次数为log_2(N!)，约等于Nlog_2N。这就是基于比较的排序算法的最优复杂度：O(nlog_2n)。<br>上述第一种猜数字方法就是有序数组中的顺序查找，第二种是二分查找，算法时间复杂度为O(log_2n)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = array.length;</span><br><span class="line">	<span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = len - <span class="number">1</span>;</span><br><span class="line">    whlie(low &lt;= high)&#123;</span><br><span class="line">    	<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">if</span>(key == array[mid])&#123;</span><br><span class="line">    		<span class="keyword">return</span> mid;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; array[mid])&#123;</span><br><span class="line">    		low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有序数组的二分查找已经是采用最优策略的方式了，为什么要引入二叉查找树呢？<br>首先，二叉查找树每个节点都大于其左子树任意节点，小于右子树中的任意节点。查找时，每次比较都至少砍掉了在该节点某一个子树上的可能性，当树平衡的时候，这一点同二分查找是差不多的。<code>当树退化为一棵斜树时不然，查找的复杂度退化为O(n)</code>。<br>其次，二叉查找树拥有二分查找无法企及的优势：插入快速。<br>基于二分查找向空表中插入N个元素的时间复杂度为O(n^2)，而二叉查找树插入操作是时间复杂度约是O(log_2n)，是对数级别的。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/2010062717002636.png" alt="二叉查找树插入图示"></p>
<h2 id="二、二叉查找树的实现">二、二叉查找树的实现</h2><p>1.基本结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">binarySearchTree</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">		<span class="keyword">private</span> Node leftChild;</span><br><span class="line">		<span class="keyword">private</span> Node rightChild;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//见2</span></span><br><span class="line">		<span class="comment">//找到值等于value的节点返回true，否则返回false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//见3</span></span><br><span class="line">		<span class="comment">//查找适合的位置执行插入操作，插入的永远都是叶子节点（树初始为空时为根节点）</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//见4</span></span><br><span class="line">		<span class="comment">//返回删除之后补位的节点，未找到待删除节点返回null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.二叉查找树的查找操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> current = root.value;</span><br><span class="line">	<span class="keyword">if</span>(current &gt; value)&#123;</span><br><span class="line">		<span class="keyword">return</span> get(root.leftChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current &lt; value)&#123;</span><br><span class="line">		<span class="keyword">return</span> get(root.rightChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.二叉查找树的插入操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	root = put(root,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">		Node node = <span class="keyword">new</span> Node(value);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> current = root.value;</span><br><span class="line">	<span class="keyword">if</span>(current &gt; value)&#123;</span><br><span class="line">		root.leftChild = put(root.leftChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current &lt; value)&#123;</span><br><span class="line">		root.rightChild = put(root.rightChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>;<span class="comment">//相等不作操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<em>二叉查找树的删除操作</em><br>首先找到要删除的节点，未找到不执行删除。第一种情况：要删除的节点没有左右子节点，直接删除即可（将父节点指向自身的链接置null）。<br>第二种情况：要删除的节点只有一个子节点，将子节点直接替换自身即可。<br>第三种情况：要删除的节点拥有左右子节点，这种情况比较复杂。基本思路就是删除节点后，用他的直接<code>后继节点</code>填补位置。<br>这个后继节点其实就是二叉查找树中序遍历的直接后继节点，就是其右子树中的最小节点（该节点一定不含有左子节点），这样可以用最小的代价来执行删除。</p>
<ul>
<li>令sonOfX=x的后继节点：min(x.rightChild)</li>
<li>sonOfX.rightChild指向removeMin(x.rightChild)，也就是指向删掉后继节点的x的右子树。</li>
<li>sonOfX.leftChild指向原来x.leftChild。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/IMG_20150623_224106.jpg" alt="删除图示"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> current = root.value;</span><br><span class="line">	<span class="keyword">if</span>(current &gt; value)&#123;</span><br><span class="line">		root.leftChild = remove(root.leftChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current &lt; value)&#123;</span><br><span class="line">		root.rightChild = remove(root.rightChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//找到删除位置</span></span><br><span class="line">		<span class="keyword">if</span>(root.rightChild == <span class="keyword">null</span>) <span class="keyword">return</span> root.leftChild;</span><br><span class="line">		<span class="keyword">if</span>(root.leftChild == <span class="keyword">null</span>) <span class="keyword">return</span> root.rightChild;</span><br><span class="line">		Node sonOfRoot = min(root.rightChild);  <span class="comment">//待删除节点的直接后继节点</span></span><br><span class="line">		sonOfRoot.rightChild = removeMin(root.rightChild);</span><br><span class="line">		sonOfRoot.leftChild = root.leftChild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sonOfRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">min</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">	<span class="comment">//找出root最小节点</span></span><br><span class="line">	<span class="keyword">if</span>(root.leftChild == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	<span class="keyword">return</span> min(root.leftChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">removeMin</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">	<span class="comment">//删除root子树中最小的节点</span></span><br><span class="line">	<span class="keyword">if</span>(root.leftChild == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> root.rightChild;</span><br><span class="line">	root.leftChild = removeMin(root.leftChild);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、二叉查找树的基本特点">一、二叉查找树的基本特点</h2><blockquote>
<p>二叉查找树的定义：二叉查找树（BST，又叫二叉排序树）是一棵二叉树，其中每一个节点都包含两个指向两个孩子的指针域和一个实现了comparable接口的数据域。并且，每个节点都大于其左子树任意节点，小于右子树中的任意节点。</p>
</blockquote>
<p>抄书完毕，那么为什要建立这样的一个数据结构呢？</p>
<p>玩一个猜数字的游戏，1~64之间（假设目标数字为20）。<br>“1”  “低了”  “2”  “低了”  “3”  “低了”  “4” “低了”……     锲而不舍型要猜上20次。<br>“32”  “高了”  “16”  “低了”  “24”  “高了”  “20”  “答对了”     机智折半型只需要猜4次。<br>无论目标数字如何刁钻，采用折半的策略都能在log_2n次以内猜中。<br>因为这样每一次都能够排除掉一半的可能性，也就是说折半策略每一次都将问题的解空间折半。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="数据结构" scheme="http://ningquec.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://ningquec.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>