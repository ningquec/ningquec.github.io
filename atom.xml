<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Tyrone Li的博客]]></title>
  <subtitle><![CDATA[天天向上]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ningquec.github.io//"/>
  <updated>2015-07-14T11:32:24.756Z</updated>
  <id>http://ningquec.github.io//</id>
  
  <author>
    <name><![CDATA[Tyrone]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[正则表达式解决方程是否有解问题]]></title>
    <link href="http://ningquec.github.io/2015/07/14/RELinearEquation/"/>
    <id>http://ningquec.github.io/2015/07/14/RELinearEquation/</id>
    <published>2015-07-14T11:22:24.000Z</published>
    <updated>2015-07-14T11:32:24.756Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>部分译自<a href="http://blog.stevenlevithan.com/archives/algebra-with-regexes" target="_blank" rel="external">http://blog.stevenlevithan.com/archives/algebra-with-regexes</a></p>
</blockquote>
<p>正则表达式在数学上的应用是弱项。对于一个正则表达式引擎来说，0~9这10个字符是最为特殊的。</p>
<p>必须说明Perl和PCRE是个例外，它们允许在匹配进程中的任何一点插入执行动态代码，这也显示了它们的巨大潜力。Perl可以在正则表达式中插入代码，PCRE可以调用外部函数。总的来说，用正则表达式解决数学问题是永远的隐痛。</p>
<p>然而，最基本的正则表达式也可以榨出更多美味的汁来。它甚至可以<a href="http://coolshell.cn/articles/2704.html" target="_blank" rel="external">匹配素数</a>。下面的例子可能让你更加惊艳：<b>正则表达式能判断线性方程是否有解！</b></p>
<p>基本正则表达式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(.*)\1&#123;A&#8722;1&#125;(.*)\2&#123;B&#8722;1&#125;$</span><br></pre></td></tr></table></figure></p>
<p>其中A和B为占位符，使用时候用未知数的系数替换。这里会看的很迷糊，最下面再解释。例如17x+12y=51，A和B就被分别替换为17和12。如果我们将51的字符串代入来匹配，第一个子表达式结果会是3，第二个子表达式会是0，表示x=3，y=0，也就是说这个方程有解。如果方程无解，正则表达式就匹配失败；如果方程有多组解，正则表达式会匹配到x最大的情况。</p>
<p>注意，这样只是看起来很酷。其实正则引擎匹配时会发生多次回溯，某些情况下效率相当低……</p>
<hr>
<p>首先介绍一下如何匹配，还是以17x+12y=51为例。<br>正则表达式代入A和B：<code>^(.*)\1{16}(.*)\2{11}$</code>。前半部分(.*)\1{16}表示先匹配一个(.*),即任意个重复字符，假定为“11”，那么然后会重复匹配16次“11”。后半部分同理。<br>在匹配的时候，我们会先把51转换为一个“11……11”（共51个1）的字符串，然后进行匹配。<br>我们之所以将A、B减去1是因为我们已经在子表达式中（括号中的部分）匹配了一次模式。</p>
<p>下面说明一下其数学原理：<br>我们把(.*)看做是(1*)，即匹配若干个1。匹配成功的情况为：<br>1.匹配一个“111”，剩下51-3=448个1。<br>2.重复16次“111”，共16*3=48。<br>3.51个1匹配成功。<br>4.后半部分(.*)\2{11}重复匹配12次空串，(.*)此时为0个1。</p>
<p>也就是说，正则表达式匹配方程是否有解其实是利用了类似穷举的方式。在最开始，正则引擎可能尝试了以17个空串开头、17个“1”开头、17个“11”开头的情况，类似于尝试17*0+12y=51、17*1+12y=51、17*2+12y=51，但都无法得出恰当的y来完成匹配。</p>
<p>假如我想要匹配一个7位数，17x+12y=1700012。其中的一组解为x=100000，y=1，正则引擎要从0个1试验到100000个1开头……它看了这个七位数一眼，一眼就是万年……</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>部分译自<a href="http://blog.stevenlevithan.com/archives/algebra-with-regexes" target="_blank" rel="external">http://blog.steven]]>
    </summary>
    
      <category term="正则表达式" scheme="http://ningquec.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK1.8中的HashMap介绍和思考]]></title>
    <link href="http://ningquec.github.io/2015/07/11/CollectionHashMap/"/>
    <id>http://ningquec.github.io/2015/07/11/CollectionHashMap/</id>
    <published>2015-07-11T05:36:49.000Z</published>
    <updated>2015-07-12T09:01:36.739Z</updated>
    <content type="html"><![CDATA[<h2 id="一、简介">一、简介</h2><blockquote>
<p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</blockquote>
<ol>
<li>用来存储键值对（Key-Value）。所以我们可以用它来快速匹配映射关系，例如词串的出现次数、国家的首都、小游戏中状态是否合法等等。</li>
<li>是一个散列表。所以它存取较快，同时需要好的hash函数和碰撞处理。</li>
</ol>
<p>JDK1.8以前，HashMap采用“拉链法”来实现：如图，使用数组+链表来处理冲突。使用hash函数得到一个数组索引，同一个Hash值的键值对存储在一个链表里。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/20130314151321_611.jpg?imageView2/0/w/400/" alt="拉链法图示"><br>当链表很长的时候，会导致查询速度变慢，所以在这个版本中，将链表做了一点小小的改动。当链表长度超过8时，链表将转化为一棵红黑树，这样查找时间就从O(n)降低到了O(log_2n)。下面就通过源码来讲解一下HashMap的具体实现。<br><a id="more"></a></p>
<h2 id="二、HashMap的实现">二、HashMap的实现</h2><h3 id="（1）数据结构">（1）数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点数据结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;  <span class="comment">//next指向下一个节点，处理hash冲突</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	<span class="comment">//重写hashCode()，key和value的hashCode()相异或</span></span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="comment">//当key和value都相等时，说明两个节点相等</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储节点的数组</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储被修改的次数</span></span><br><span class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//临界值，当临界值大于容量*加载因子时，需要进行扩容</span></span><br><span class="line"> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子，默认为0.75，即实际的元素占容量的75%</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）初始化一个HashMap">（2）初始化一个HashMap</h3><p>HashMap的默认初始容量为16（<code>Node&lt;K,V&gt;[] table</code>的长度为16），最大容量为<code>1&lt;&lt;30</code>，默认装载因子为0.75。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></p>
<p>HashMap提供了四个构造函数来初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//初始容量应该大于0</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        <span class="comment">//初始容量不能超过最大容量</span></span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="comment">//装载因子应该大于0</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap使用tableSizeFor()方法来保证HashMap的容量一定为2的整数次幂。原因在下面说明。</p>
<h3 id="（3）put方法">（3）put方法</h3><p><img src="http://7xjnnt.com1.z0.glb.clouddn.com/72586658458581450.jpg" alt="put图示"></p>
<ol>
<li>判断<code>Node&lt;K,V&gt;[] table</code>是否合法，是否需要执行resize操作</li>
<li>通过hash&amp;（数组长度-1）得到索引位置。</li>
<li>如果该节点不存在，新建一个插入，否则更新节点内容。</li>
</ol>
<p>可以看到put方法计算数组索引是通过和Node数组长度(length)减一得到的。如果容量不是2的整数次幂，length-1的最后一位一定是0，同hash值相与的结果最后一位一定也是0.<br>也就是说，索引位置一定出现在偶数位，这是不符合保持均匀的基本要求的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">//如果数组为空或者长度为0，执行resize扩容</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="comment">//hash&amp;（数组长度-1）得到索引位置</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            	<span class="comment">//如果索引位置冲突，且带插入节点的key值已经存在</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            	<span class="comment">//如果是一个红黑树节点，说明链表已经变为红黑树，调用树的插入方法</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                	<span class="comment">//如果链表中没有找到Key相同的节点，则新建节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            	<span class="comment">//对于hash和Key的值都相同的节点，更新其value</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）get方法">（4）get方法</h3><p>get方法的基本思想同put()相同</p>
<ol>
<li>检验<code>Node&lt;K,V&gt;[] table</code>是否合法</li>
<li>通过hash&amp;（数组长度-1）得到索引位置。</li>
<li>遍历链表或者红黑树，找到节点。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="keyword">int</span> hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp;  ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="（5）resize方法">（5）resize方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            	<span class="comment">//如果原始容量超过了最大容量，那么就不能扩容了，只能增大临界值。</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 扩容为原来的两倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">//如果原始容量&lt;=0且临界值&lt;=0（相当于需要重新初始化）使用默认容量和默认临界值。              </span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    	<span class="comment">//对于原始HashMap中的元素，要重新计算索引位置</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; </span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】以上几种方法均需要分链表和红黑树进行讨论。</p>
<h2 id="一些思考">一些思考</h2><p>以前介绍Hash表时说，采用线性探测法处理碰撞时最好令装载因子为0.5，也就是占总容量一半时性能最佳。这是对于空间和时间复杂度的一种权衡。<br>同理，HashMap中也做了这样的权衡。装载因子过高虽然减少了空间开销，但同时也增加了查询成本。<br>在设置初始容量时应该考虑到映射中所需的条目数及其装载因子，以便最大限度地减少resize()操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 resize()操作。 </p>
<p>如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 resize() 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。</p>
<p>JDK1.8中基于查询插入速度的考量，当链表太长时将链表自动转换为红黑树。<br>我最开始的想法是，Hash函数的选择一般都很能保证均匀性，链表有可能在达到临界值之前，长度达到8以上吗？</p>
<p>设想一种极端情况：hash函数被别人获知，不停的恶意put hash值映射索引相同的键值对，此时的链表会不断变长，查询效率就会越来越低。然而元素的总个数还远远没有达到容量*loadFactor的地步（假设容量很大）。这样使用红黑树就能大大降低时间了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、简介">一、简介</h2><blockquote>
<p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</blockquote>
<ol>
<li>用来存储键值对（Key-Value）。所以我们可以用它来快速匹配映射关系，例如词串的出现次数、国家的首都、小游戏中状态是否合法等等。</li>
<li>是一个散列表。所以它存取较快，同时需要好的hash函数和碰撞处理。</li>
</ol>
<p>JDK1.8以前，HashMap采用“拉链法”来实现：如图，使用数组+链表来处理冲突。使用hash函数得到一个数组索引，同一个Hash值的键值对存储在一个链表里。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/20130314151321_611.jpg?imageView2/0/w/400/" alt="拉链法图示"><br>当链表很长的时候，会导致查询速度变慢，所以在这个版本中，将链表做了一点小小的改动。当链表长度超过8时，链表将转化为一棵红黑树，这样查找时间就从O(n)降低到了O(log_2n)。下面就通过源码来讲解一下HashMap的具体实现。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="集合类" scheme="http://ningquec.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[shell脚本编程小技巧]]></title>
    <link href="http://ningquec.github.io/2015/07/10/ShellProgrammingSkills/"/>
    <id>http://ningquec.github.io/2015/07/10/ShellProgrammingSkills/</id>
    <published>2015-07-10T13:21:27.000Z</published>
    <updated>2015-07-22T07:48:10.349Z</updated>
    <content type="html"><![CDATA[<p>总结的一些shell小技巧，时时更新中。。</p>
<p>（1）使用&amp;&amp;和||的短路特性，假如传递了参数，PARAM=参数，否则给PARAM赋一个值。（简化if else）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -n &#34;$1&#34; ]] &#38;&#38; PARAM=$1 || PARAM=value</span><br></pre></td></tr></table></figure></p>
<p>（2）测试上一个命令的退出状态，将错误写入log文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $? &#8211;gt 0 ] &#38;&#38; echo &#39;Something Wrong, please investigate!&#39; &#62;&#62; $&#123;LOG_FILE&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）脚本中产生的一些文件，比如log之类记得最后赋以合适的权限和群组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -type f -mtime -1 &#8211;user `whoami` -exec chmod 777 &#123;&#125; \;&#10;find -type f -mtime -1 &#8211;user `whoami` -exec chgrp group &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>（4）删除掉脚本中的无用空行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#34;^$ d&#34; file</span><br></pre></td></tr></table></figure></p>
<p>（5）测试脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -n script #&#26816;&#27979;&#35821;&#27861;&#65292;&#19981;&#20250;run&#33050;&#26412;&#10;sh -x script #shell&#22312;&#25191;&#34892;&#33050;&#26412;&#30340;&#36807;&#31243;&#20013;&#25226;&#23427;&#23454;&#38469;&#25191;&#34892;&#30340;&#27599;&#19968;&#20010;&#21629;&#20196;&#34892;&#26174;&#31034;&#20986;&#26469;&#65292;&#24182;&#19988;&#22312;&#34892;&#39318;&#26174;&#31034;&#19968;&#20010;&#34;+&#34;&#21495;&#12290; &#10;&#10;&#10;#&#34;+&#34;&#21495;&#21518;&#38754;&#26174;&#31034;&#30340;&#26159;&#32463;&#36807;&#20102;&#21464;&#37327;&#26367;&#25442;&#20043;&#21518;&#30340;&#21629;&#20196;&#34892;&#30340;&#20869;&#23481;&#65292;&#26377;&#21161;&#20110;&#20998;&#26512;&#23454;&#38469;&#25191;&#34892;&#30340;&#26159;&#20160;&#20040;&#21629;&#20196;&#12290;&#10;#&#22312;&#36305;&#33050;&#26412;&#20043;&#21069;&#25191;&#34892;sh &#8211;n &#26159;&#24456;&#22909;&#30340;&#20064;&#24815;&#65292;-x&#21487;&#20197;&#24110;&#21161;&#25105;&#20204;&#20851;&#27880;&#21040;&#36816;&#31639;&#32467;&#26524;&#65292;&#36923;&#36753;&#21028;&#26029;&#32467;&#26524;&#65292;&#21464;&#37327;&#36171;&#20540;&#31561;&#31561;&#12290;</span><br></pre></td></tr></table></figure></p>
<p>（6）将一部分必要的环境配置写入文件，并且在脚本开始调用该文件。例如配置sas环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAS_HOME=sas_path/sas&#10;SAS_TEST=&#8221;$&#123;SAS_HOME&#125; -nonews -stdio -nosyntaxcheck&#34;</span><br></pre></td></tr></table></figure></p>
<p>同时使用恰当的alias能简洁脚本，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias grep=&#34;grep &#8211;rE --color&#34;&#10;alias c=&#39;clear&#39;&#10;alias x=&#39;exit&#39;&#10;alias ll=&#39;ls -l&#39;&#10;alias ldir=&#39;ls -l | grep &#34;^d&#34;&#39;</span><br></pre></td></tr></table></figure></p>
<p>(8)一定要慎用rm命令！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>总结的一些shell小技巧，时时更新中。。</p>
<p>（1）使用&amp;&amp;和||的短路特性，假如传递了参数，PARAM=参数，否则给PARAM赋一个值。（简化if else）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -n &#34;$1&#34; ]] &#38;&#38; PARAM=$1 || PARAM=value</span><br></pre></td></tr></table></figure></p>
<p>（2）测试上一个命令的退出状态，将错误写入log文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ $? &#8211;gt 0 ] &#38;&#38; echo &#39;Something Wrong, please investigate!&#39; &#62;&#62; $&#123;LOG_FILE&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）脚本中产生的一些文件，比如log之类记得最后赋以合适的权限和群组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -type f -mtime -1 &#8211;user `whoami` -exec chmod 777 &#123;&#125; \;&#10;find -type f -mtime -1 &#8211;user `whoami` -exec chgrp group &#123;&#125; \;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树（二）：红黑树续篇]]></title>
    <link href="http://ningquec.github.io/2015/07/07/DataStructureRBT2/"/>
    <id>http://ningquec.github.io/2015/07/07/DataStructureRBT2/</id>
    <published>2015-07-07T13:23:50.000Z</published>
    <updated>2015-07-08T14:21:34.815Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>1.每个节点只能是黑色或者红色。<br>2.根节点为黑色。<br>3.红色节点的儿子必须都是黑色。<br>4.对每个节点，从该节点到其子孙节点的所有路径上包含相同数目的黑节点（黑色平衡）。</p>
</blockquote>
<p>回顾一下红黑树的重要性质，下面讨论红黑树的删除操作。<br>红黑树的删除同样是按照二叉查找树的方式查找待删除节点，之后需要考虑在不违反以上性质的情况下删除该节点。<br><a id="more"></a><br>首先找出待删除节点的后继节点x，替换待删除节点的位置。为什么用后继节点替换在<a href="http://tyroneli.com/2015/06/22/DataStructureBST/" target="_blank" rel="external">二叉查找树</a>中有提到。<br>同样的，我们约定几个变量。y为删除的节点，x为y后继节点，也就是新的需调整节点，xp为x的父节点，xpp为xp的父节点，xppl为xpp的左孩子。。类推。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4696169845330901090.jpg?imageView2/0/w/400/h/300" alt="变量图示"><br>（一）删除单支红色节点y，这种情况直接删除，不影响黑色平衡。<br>（二）待删除的节点y为黑色，用后继节点x替换，且x为红色。此时将x变为黑色即可。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/5386089682175726007.jpg" alt="x为红色的情况"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">    x.red = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（三）待删除的节点y为黑色，用后继节点x替换，且x为黑色。删除y之后，x相对于xpr的子树就少了一个黑色节点，需要进行调整。且情况分为以下四种：【注】图中只是树的一部分，x要比xpr少一个黑色子节点。</p>
<p>（1）x的兄弟xpr是红色的。对于这种情况，xpr变为黑色，xp变为红色，对xp左旋。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4641605893048654080.jpg"></p>
<p>（2）x的兄弟xpr是黑色的，且xpr的俩个孩子都是黑色的。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8390039386922256530.jpg"></p>
<p>（3）x的兄弟xpr是黑色的，xpr左孩子红色，右孩子黑色。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/5891667748188383744.jpg"></p>
<p>（4）x的兄弟xpr是黑色的，xpr的右孩子为红色。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8185952396087129951.jpg"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">        xpr.red = <span class="keyword">false</span>;</span><br><span class="line">        xp.red = <span class="keyword">true</span>;</span><br><span class="line">        root = rotateLeft(root, xp);</span><br><span class="line">        xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">        x = xp;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        RedBlackTree sl = xpr.left, sr = xpr.right;</span><br><span class="line">        <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp; (sl == <span class="keyword">null</span> || !sl.red)) &#123;            </span><br><span class="line">            xpr.red = <span class="keyword">true</span>;</span><br><span class="line">            x = xp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateRight(root, xpr);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">            &#125;</span><br><span class="line">            x = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上删除操作是默认x为左节点，右节点的情况同理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>1.每个节点只能是黑色或者红色。<br>2.根节点为黑色。<br>3.红色节点的儿子必须都是黑色。<br>4.对每个节点，从该节点到其子孙节点的所有路径上包含相同数目的黑节点（黑色平衡）。</p>
</blockquote>
<p>回顾一下红黑树的重要性质，下面讨论红黑树的删除操作。<br>红黑树的删除同样是按照二叉查找树的方式查找待删除节点，之后需要考虑在不违反以上性质的情况下删除该节点。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="数据结构" scheme="http://ningquec.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://ningquec.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sed命令详解]]></title>
    <link href="http://ningquec.github.io/2015/07/02/LinuxCommandSed/"/>
    <id>http://ningquec.github.io/2015/07/02/LinuxCommandSed/</id>
    <published>2015-07-02T10:51:48.000Z</published>
    <updated>2015-07-02T10:56:44.217Z</updated>
    <content type="html"><![CDATA[<h2 id="一、简介">一、简介</h2><p>sed命令是一个很强大的文本编辑器，可以对来自文件、以及标准输入的文本进行编辑。</p>
<p>执行时，sed会从文件或者标准输入中读取一行，将其复制到缓冲区，对文本编辑完成之后，读取下一行直到所有的文本行都编辑完毕。<br>所以sed命令处理时只会改变缓冲区中文本的副本，如果想要直接编辑原文件，可以使用-i选项或者将结果重定向到新的文件中。</p>
<p>sed命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [options] commands [inputfile...]</span><br></pre></td></tr></table></figure></p>
<p>options表示sed命令的一些选项，常见的选项如下表：<br><a id="more"></a></p>
<p><table><tr><th>选项名</th><th>作用</th></tr><tr><td>-n</td><td>取消默认输出</td></tr><tr><td>-e</td><td>多点编辑，可移执行多个子命令</td></tr><tr><td>-f</td><td>从脚本文件中读取命令（sed操作可以事先写入脚本，然后通过-f读取并执行）</td></tr><tr><td>-i</td><td>直接编辑原文件</td></tr><tr><td>-l</td><td>指定行的长度</td></tr><tr><td>-r</td><td>在脚本中使用扩展表达式</td></tr></table></p>
<h2 id="二、应用场景">二、应用场景</h2><p>sed命令比较适用于大的文本文件，用普通文本编辑器难以胜任的情况。下面分别介绍直接打印、插入、删除、替换等编辑操作。<br>&nbsp;&nbsp;&nbsp;实验用文件内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#===================test1.txt======================&#10;letitia&#10;mail&#10;uuencode&#10;1003605091&#10;01566</span><br></pre></td></tr></table></figure></p>
<p>（1）行打印，输出缓冲区内容，使用sed的<code>p子命令</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;1,3 p&#39; test1.txt&#10;echo &#34;=====================&#34;&#10;sed -n &#39;1,3 p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;letitia&#10;mail&#10;mail&#10;uuencode&#10;uuencode&#10;1003605091&#10;01566&#10;=====================&#10;letitia&#10;mail&#10;uuencode</span><br></pre></td></tr></table></figure></p>
<p>p子命令代表print，可以打印出sed缓冲区内的内容。<br>sed命令中，直接采用数字代表某个特定的文本行：<code>&#39;1 p&#39;</code>代表打印第一行；<code>&#39;1,3 p&#39;</code>代表打印1到3行；特别的，最后一行的行号为$。</p>
<p>观察输出结果，不使用-n选项时，sed命令把1到3行输出了两次。这是因为不使用-n时，sed首先读取一行，并默认将缓冲区内的文本输出出来，之后p子命令再次输出。使用-n时，默认输出取消，只有p子命令的输出结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;/^ma/,5 p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;mail&#10;uuencode&#10;1003605091&#10;01566</span><br></pre></td></tr></table></figure></p>
<p>sed命令支持正则表达式定位。语法为<code>/re/</code>，re表示正则表达式。<br>本例表示打印出从匹配正则表达式的地方到第5行，也就是从匹配以ma开头的文本行处开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;1~2 p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;uuencode&#10;01566</span><br></pre></td></tr></table></figure></p>
<p><code>1~2</code>表示从第一行开始，行号递增2输出，即输出奇数行。语法格式为<code>first~step</code>。<br>（2）插入文本行，追加文本行<br>这两种情况很类似。插入文本使用<code>i子命令</code>，表示在指定位置前面插入文本；追加文本使用<code>a子命令</code>，表示在指定位置之后插入文本。观察一下两个的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;2 i insert&#39; -e &#39;1,4 p&#39; test1.txt &#10;&#10;#-e&#36873;&#39033;&#34920;&#31034;&#22810;&#20010;&#23376;&#21629;&#20196;&#65292;&#26412;&#20363;&#25191;&#34892;i&#23376;&#21629;&#20196;&#20043;&#21518;&#25191;&#34892;&#20102;p&#23376;&#21629;&#20196;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;insert&#10;mail&#10;uuencode&#10;1003605091</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;2 a insert&#39; -e &#39;1,4 p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;mail&#10;insert&#10;uuencode&#10;1003605091</span><br></pre></td></tr></table></figure>
<p>（3）删除文本行，使用<code>d子命令</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;2 d&#39; -e &#39;1,$ p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;uuencode&#10;1003605091&#10;01566</span><br></pre></td></tr></table></figure></p>
<p>（4）替换文本行，使用<code>c子命令</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;2 c newmail&#39; -e &#39;1,$ p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;newmail&#10;uuencode&#10;1003605091&#10;01566</span><br></pre></td></tr></table></figure></p>
<p>【注】以上均未使用-i选项，所以更改的只是副本。<br><b>（5）替换指定文本，使用<code>s子命令</code></b><br>这一个命令实用性很广，并且灵活。语法也比之上面特别一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;&#20301;&#32622;&#21442;&#25968; s/pattern/replaced/[flag]&#39;</span><br></pre></td></tr></table></figure></p>
<p>pattern为要替换的文本，支持正则表达式，replaced表示用来替换的一般字符串（不支持正则表达式）。<br>flag是替换标志，用来影响匹配替换的规则：</p>
<p><table><tr><th>flag</th><th>用法</th></tr><tr><td>g</td><td>全局匹配，会替换文本行中所有匹配的字符串</td></tr><tr><td>十进制n</td><td>替换文本行中第n个匹配的字符串</td></tr><tr><td>p</td><td>替换第一个匹配的字符串，并且将缓冲区输出到标准输出</td></tr><tr><td>w</td><td>替换第一个匹配的字符串，并且将改动的行输出到磁盘文件中</td></tr><tr><td>缺省</td><td>替换第一个匹配的字符串</td></tr></table><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;s/[0-9]\&#123;10\&#125;/miss letitia/g&#39; -e &#39;1,$ p&#39; test1.txt&#10;#&#123;&#125;&#35201;&#36716;&#20041;&#65292;&#22240;&#20026;&#27492;&#22788;&#20351;&#29992;&#30340;&#19981;&#26159;&#25193;&#23637;&#27491;&#21017;&#34920;&#36798;&#24335;&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;letitia&#10;mail&#10;uuencode&#10;miss letitia&#10;01566</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n -e &#39;1,/^ma/ s/l/L/g&#39; -e &#39;1,$ p&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;Letitia&#10;maiL&#10;uuencode&#10;miss letitia&#10;01566&#10;#&#21487;&#20197;&#30475;&#21040;&#65292;&#26412;&#20363;&#23558;&#21069;&#20004;&#34892;&#37324;&#30340;l&#26367;&#25442;&#20026;L&#12290;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;1,3&#123;&#10;            s/l/L/g&#10;            s/e/E/g&#10;            2 i tyrone&#10;            p&#10;            &#125;&#39; test1.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;LEtitia&#10;tyrone&#10;maiL&#10;uuEncodE</span><br></pre></td></tr></table></figure>
<p>最后这个例子比较复杂。使用大括号，表示对1到3行做了一组操作。</p>
<h2 id="三、其他的小事">三、其他的小事</h2><ul>
<li><p>以上都是采用了文件输入做实验，也可以采用其他方式，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#34;s/letitia/hello world/g&#34; `grep &#34;letitia&#34; -rl test1.txt`&#10;#&#23558;grep&#30340;&#32467;&#26524;&#20316;&#20026;&#36755;&#20837;&#65292;&#27880;&#24847;&#35201;&#29992;&#21453;&#24341;&#21495;&#25324;&#36215;&#26469;&#65292;&#23558;&#25324;&#21495;&#20869;&#37096;&#20998;&#35299;&#37322;&#20026;linux&#21629;&#20196;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当用户的编辑操作比较复杂时，建议使用sed脚本文件。</p>
</li>
<li>同正则表达式一样，匹配元字符时要用转义。使用基本正则表达式时，{}等也要转义。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、简介">一、简介</h2><p>sed命令是一个很强大的文本编辑器，可以对来自文件、以及标准输入的文本进行编辑。</p>
<p>执行时，sed会从文件或者标准输入中读取一行，将其复制到缓冲区，对文本编辑完成之后，读取下一行直到所有的文本行都编辑完毕。<br>所以sed命令处理时只会改变缓冲区中文本的副本，如果想要直接编辑原文件，可以使用-i选项或者将结果重定向到新的文件中。</p>
<p>sed命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [options] commands [inputfile...]</span><br></pre></td></tr></table></figure></p>
<p>options表示sed命令的一些选项，常见的选项如下表：<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树（二）：红黑树]]></title>
    <link href="http://ningquec.github.io/2015/06/30/DataStructureRBT/"/>
    <id>http://ningquec.github.io/2015/06/30/DataStructureRBT/</id>
    <published>2015-06-30T12:45:05.000Z</published>
    <updated>2015-07-07T13:32:58.913Z</updated>
    <content type="html"><![CDATA[<h2 id="一、简介">一、简介</h2><p>上一篇中介绍了二叉查找树的特性，其中提到二叉查找树查找插入操作的时间复杂度约是O(log_2n)，但这只是在最优状态下。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4310693094167885900.jpg?imageView2/0/w/300/h/250" alt="二叉查找树退化为斜树"><br>所以我们希望得到一棵基本维持平衡的二叉查找树，在最坏的情况下时间复杂度也能达到O(log_2n)。于是红黑树应运而生。</p>
<p>红黑树是这样的一种二叉查找树（是的，它满足二叉查找树的所有性质）：每个节点都含有5个域，包括指向左右孩子的指针、指向父节点的指针、数据域和颜色。如果相应的指针为空设为NIL。同时符合以下4大性质：<br><a id="more"></a></p>
<blockquote>
<p>1.每个节点只能是黑色或者红色。<br>2.根节点为黑色。<br>3.红色节点的儿子必须都是黑色。<br>4.对每个节点，从该节点到其子孙节点的所有路径上包含相同数目的黑节点（黑色平衡）。</p>
</blockquote>
<p>这样的目的是什么呢？见下图<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/13124250-82a6750fab4343a28f78de1aaca37bae.jpg" alt="红黑树"><br>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长（可以反证）。所以红黑树大致上能够保持平衡。</p>
<h2 id="二、红黑树的建立">二、红黑树的建立</h2><p>下面开始建立一棵红黑树。红黑树的基本数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackTree</span> </span>&#123;</span><br><span class="line">	RedBlackTree parent;</span><br><span class="line">	RedBlackTree left;</span><br><span class="line">	RedBlackTree right;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">boolean</span> red;</span><br><span class="line">	RedBlackTree(<span class="keyword">int</span> val, RedBlackTree parent, RedBlackTree left, RedBlackTree right, <span class="keyword">boolean</span> red)&#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">		<span class="keyword">this</span>.parent = parent;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">		<span class="keyword">this</span>.red = red;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>红黑树的插入操作同二叉查找树基本相同，只是要多考虑颜色的因素。插入时，总是插入红色的节点，这样可以尽量的保持完美黑色平衡。<br>同时也可能会出现不符合4大性质的情况，所以需要在插入后对树进行动态调整。<br>也就是说，我们先按照二叉查找树的方式插入红色节点，之后进行树的调整操作。<br>基本思想是把出现违背红黑树性质的结点向上移，如果能移到根结点，那么很容易就能通过直接修改根结点来恢复红黑树的性质。</p>
<p>调整涉及左旋和右旋两种操作，如图：<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/2981960730598275566.jpg?imageView2/0/w/400/h/300" alt="左旋图示"><br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8845355295264617830.jpg?imageView2/0/w/400/h/300" alt="右旋图示"><br>对pivot左旋：</p>
<ol>
<li>y = pivot.right。pivot的右孩子为y</li>
<li>privt.right = y.left, y.parent = x.parent。把y的左孩子作为pivot的右孩子，y取代pivot的位置</li>
<li>y.left = privt。把pivot作为y的左孩子。</li>
</ol>
<p>这样做不会改变树的排序性质，但是可能破坏了颜色性质，调整往往需要和重新涂色一起进行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RedBlackTree <span class="title">rotateLeft</span><span class="params">(RedBlackTree root, RedBlackTree pivot)</span></span>&#123;</span><br><span class="line">	RedBlackTree y,yl,yp;</span><br><span class="line">	<span class="keyword">if</span>(pivot != <span class="keyword">null</span> &amp;&amp; (y = pivot.right) != <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>((yl = pivot.right = y.left) != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//把y的左孩子yl作为pivot的右孩子</span></span><br><span class="line">			yl.parent = pivot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((yp = y.parent = pivot.parent) == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//如果y的parent为空，说明它是root节点，涂黑</span></span><br><span class="line">			(root = y).red =<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(yp.left == pivot)&#123;</span><br><span class="line">			yp.left = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			yp.right = y;</span><br><span class="line">		&#125;</span><br><span class="line">		y.left = pivot;</span><br><span class="line">		pivot.parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>右旋同理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RedBlackTree <span class="title">rotateRight</span><span class="params">(RedBlackTree root, RedBlackTree pivot)</span></span>&#123;</span><br><span class="line">	RedBlackTree y,yr,yp;</span><br><span class="line">	<span class="keyword">if</span>(pivot != <span class="keyword">null</span> &amp;&amp; (y = pivot.left) != <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>((yr = pivot.left = y.right) != <span class="keyword">null</span>)&#123;</span><br><span class="line">			yr.parent = pivot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((yp = y.parent = pivot.parent) == <span class="keyword">null</span>)&#123;</span><br><span class="line">			(root = y).red = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(yp.right == pivot)&#123;</span><br><span class="line">			yp.right = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			yp.left = y;</span><br><span class="line">		&#125;</span><br><span class="line">		y.right = pivot;</span><br><span class="line">		pivot.parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面分情况讨论插入节点操作：<br>约定几个变量先：x为需调整节点，xp为x的父节点，xpp为xp的父节点，xppl为xpp的左孩子。。类推。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4696169845330901090.jpg?imageView2/0/w/400/h/300" alt="变量图示"><br>（1）需调整节点x的父节点xp为空，即需调整节点为根节点，直接将颜色设为黑色。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    x.red = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）需调整节点x的父节点为黑色，或者x的父节点为根节点，不需调整。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(xp = x.parent).red || (xpp = xp.parent) ==<span class="keyword">null</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）需调整节点x的父节点xp为红色且xp为xpp的左孩子，叔叔节点（xpp.right）也是红色。<br>这种情况将x的父节点xp和叔叔节点xppr变为黑色，然后将xpp变为红色，然后将xpp作为新的节点x进行调整。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/7987311314941575918.jpg?imageView2/0/w/400/h/300"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">        xppr.red = <span class="keyword">false</span>;</span><br><span class="line">        xp.red = <span class="keyword">false</span>;</span><br><span class="line">        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">        x = xpp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（4）需调整节点x的父节点xp是红色且xp为xpp的左孩子,叔叔节点是黑色，当前节点是其父节点的右孩子。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8071829641948021744.jpg?imageView2/0/w/400/h/300"><br>这种情况在xp节点处左旋。rotateLeft(root, xp),将xp作为新的节点x进行调整。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == xp.right &amp;&amp; xp == (xppl = xpp.left) &amp;&amp; !xppr.red) &#123;</span><br><span class="line">    root = rotateLeft(root, x = xp);</span><br><span class="line">    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（5）需调整节点x的父节点xp是红色且xp为xpp的左孩子,叔叔节点是黑色，当前节点是其父节点的左孩子。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/2574947212204924184.jpg?imageView2/0/w/400/h/300"><br>这种情况父节点xp变为黑色，祖父节点xpp变为红色，在祖父节点处右旋。rotateRight(root, xpp)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xp != <span class="keyword">null</span> &amp;&amp; xp == (xppl = xpp.left) &amp;&amp; !xppr.red) &#123;</span><br><span class="line">    xp.red = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">        root = rotateRight(root, xpp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总的插入方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RedBlackTree <span class="title">balanceInsertion</span><span class="params">(RedBlackTree root, TRedBlackTree x)</span> </span>&#123;</span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (RedBlackTree xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                root = rotateLeft(root, x = xp);</span><br><span class="line">                xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//初始xp为xpp右孩子的情况</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、下篇">三、下篇</h2><p>红黑树的删除</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、简介">一、简介</h2><p>上一篇中介绍了二叉查找树的特性，其中提到二叉查找树查找插入操作的时间复杂度约是O(log_2n)，但这只是在最优状态下。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/4310693094167885900.jpg?imageView2/0/w/300/h/250" alt="二叉查找树退化为斜树"><br>所以我们希望得到一棵基本维持平衡的二叉查找树，在最坏的情况下时间复杂度也能达到O(log_2n)。于是红黑树应运而生。</p>
<p>红黑树是这样的一种二叉查找树（是的，它满足二叉查找树的所有性质）：每个节点都含有5个域，包括指向左右孩子的指针、指向父节点的指针、数据域和颜色。如果相应的指针为空设为NIL。同时符合以下4大性质：<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="数据结构" scheme="http://ningquec.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://ningquec.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[目录树的java实现以及Stack类的一些细节]]></title>
    <link href="http://ningquec.github.io/2015/06/27/FileTreeInJava/"/>
    <id>http://ningquec.github.io/2015/06/27/FileTreeInJava/</id>
    <published>2015-06-27T08:58:57.000Z</published>
    <updated>2015-07-07T13:24:33.961Z</updated>
    <content type="html"><![CDATA[<p>使用Linux里的tree命令输出目录结构，就是下面这样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500; CNAME&#10;&#9492; _posts&#10;&#12288; &#9500; CommandFind.md&#10;&#12288; &#9500; CommandFind2.md&#10;&#12288; &#9500; CommandGrep.md&#10;&#12288; &#9500; ConcurrentHashMap.md&#10;&#12288; &#9500; DataStructureBST.md&#10;&#12288; &#9500; FileTreeInJava.md&#10;&#12288; &#9500; Grep&#38;RE.md&#10;&#12288; &#9492; HashTable&#38;BloomFilter.md</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>很炫酷，所以去找了一个java版本并学习了一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTreeTest</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileTree tree = <span class="keyword">new</span> FileTree(<span class="string">"G:/blogs/source"</span>);</span><br><span class="line">        tree.generateFileTree();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTree</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> File root;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileTree</span><span class="params">(File root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileTree</span><span class="params">(String rootName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//传入字符串作为路径</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> File(rootName));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateFileTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Stack &lt;Boolean&gt; stack = <span class="keyword">new</span> Stack &lt;Boolean&gt;();</span><br><span class="line">		tree(root , <span class="number">0</span> , stack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tree</span><span class="params">(File dir , <span class="keyword">int</span> level, Stack&lt;Boolean&gt; stack)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//递归函数</span></span><br><span class="line">		<span class="keyword">if</span>(dir == <span class="keyword">null</span> || !dir.exists())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		print(dir,level,stack);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果是文件，返回；如果是目录，递归。</span></span><br><span class="line">		<span class="keyword">if</span>(dir.isFile())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		File [] childOfDir = dir.listFiles();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childOfDir.length; i++)&#123;</span><br><span class="line">			stack.push( i == childOfDir.length - <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//标记每一个目录下的最后一个文件，因为目录树的符号不同</span></span><br><span class="line">			tree(childOfDir[i],level + <span class="number">1</span>, stack);</span><br><span class="line">			stack.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(File dir, <span class="keyword">int</span> level, Stack&lt;Boolean&gt; stack)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , k = stack.size() - <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            System.out.print(stack.get(i) ? <span class="string">"　 "</span> : <span class="string">"│ "</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(level &gt; <span class="number">0</span>) &#123;            </span><br><span class="line">            System.out.print(stack.get(stack.size() - <span class="number">1</span>) ? <span class="string">"└ "</span> : <span class="string">"├ "</span>);</span><br><span class="line">            <span class="comment">//如果是该目录下的最后一个，打印一个"└ "，否则打印"├ "</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(level == <span class="number">0</span> ? dir.getPath() : dir.getName()); </span><br><span class="line">        <span class="comment">//如果是根目录，打印出完整路径，否则只打印名字	</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码是引自<a href="http://bbs.csdn.net/topics/370068354" target="_blank" rel="external">CSDN论坛</a>。基本算法思想就是递归：访问目标路径，如果遇到一个文件，直接打印；遇到目录就先打印出来，然后将该目录作为目标路径。</p>
<hr>
<p>之后的问题就出在引用的java集合类上。Bruce大神曾经说过，不要用古老的Stack类，我一开始采用LinkedList来代替Stack，打印会出现以下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\blogs\source&#10;&#9500; CNAME&#10;&#9492; _posts&#10;&#9474; &#9492; CommandFind.md&#10;&#9474; &#9492; CommandFind2.md&#10;&#9474; &#9492; CommandGrep.md&#10;&#9474; &#9492; ConcurrentHashMap.md&#10;&#9474; &#9492; DataStructureBST.md&#10;&#9474; &#9492; FileTreeInJava.md&#10;&#9474; &#9492; Grep&#38;RE.md&#10;&#12288; &#9492; HashTable&#38;BloomFilter.md</span><br></pre></td></tr></table></figure></p>
<p>树变成了这样半身不遂的样子。我查看了这两个集合类的源代码，发现了其中的问题。原来是这两种存储方式的顺序不同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stack类的push()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    addElement(item);</span><br><span class="line">    <span class="comment">//该方法加了synchronized，定义在Vector中</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedList的push()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//初始化newNode，前驱节点为空，后继节点为f</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;  <span class="comment">//已从结构上修改此列表的次数，定义在AbstractList中，初值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，Stack类采用数组实现，push()方法将新元素加在了数组末端：<code>elementData[elementCount++] = obj</code>；<br>LinkedList是链表实现，push()方法采用了头插法。简单测试如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStack</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">		Stack &lt;Integer&gt; stack = <span class="keyword">new</span> Stack &lt;Integer&gt;();</span><br><span class="line">		LinkedList &lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">			stack.push(i);</span><br><span class="line">			list.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(stack);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		System.out.println(stack.get(<span class="number">1</span>));</span><br><span class="line">		System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>所以目录树半身不遂的根源就是由于集合类内部的不同，导致get()方法的结果不同：<code>System.out.print(stack.get(i) ? &quot;　 &quot; : &quot;│ &quot;);</code><br><code>System.out.print(stack.get(stack.size() - 1) ? &quot;└ &quot; : &quot;├ &quot;);</code>。</p>
<p>真相大白。</p>
<p>可是为什么现在要放弃Stack类，选择使用LinedList类呢？Bruce在Java编程思想中说：</p>
<blockquote>
<p>首先，Stack（堆栈）是从Vector 继承来的，亦即Stack“是”一个Vector，这种说法是不确切的。其次，对于Vector 许多重要的方法，如addElement()以及elementAt()等，它们都变成了synchronized（同步的）。这会造成显著的性能开销，可能会把final提供的性能改善抵销得一干二净。因此，程序员不得不猜测到底应该在哪里进行优化。在标准库里居然采用了如此笨拙的设计，真不敢想象会在程序员里引发什么样的情绪。</p>
</blockquote>
<p>也就是说，Stack继承自Vector，显然就像是在说：栈是一个向量！这是说不通的，Stack的继承并不是一种类型的继承（例如企鹅继承鸟类，企鹅是鸟的一个类型），而只是实现上的一个继承罢了。<br>其次，Vector里的名字也被吐槽：addElement()。。。为什么不用add()呢？<br>还有Stack会继承Vector里很多并不需要的方法：比如public void add(int index, E element)，这只会破坏Stack后进先出的规则。<br>最重要的就是性能问题。Vector是线程同步的，所以Stack里的很多方法都会有明显的同步开销，如果面对多线程的环境，最好使用java.util.concurrent包下的类，比如java.util.concurrent.ConcurrentLinkedQueue。</p>
<p>这一双父子，Vector类和Stack类，都要被丢到故纸堆去了。</p>
<p>顺便插一句，final方法性能会改善是因为</p>
<blockquote>
<p>将一个方法设成final 后，编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。只要编译器发现一个final 方法调用，就会（根据它自己的判断）忽略为执行方法调用机制而采取的常规代码插入方法（将自变量压入堆栈；跳至方法代码并执行它；跳回来；清除堆栈自变量；最后对返回值进行处理）。相反，它会用方法主体内实际代码的一个副本来替换方法调用。这样做可避免方法调用时的系统开销。当然，若方法体积太大，那么程序也会变得雍肿，可能受到到不到嵌入代码所带来的任何性能提升。因为任何提升都被花在方法内部的时间抵消了。Java 编译器能自动侦测这些情况，并颇为“明智”地决定是否嵌入一个final 方法。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用Linux里的tree命令输出目录结构，就是下面这样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500; CNAME&#10;&#9492; _posts&#10;&#12288; &#9500; CommandFind.md&#10;&#12288; &#9500; CommandFind2.md&#10;&#12288; &#9500; CommandGrep.md&#10;&#12288; &#9500; ConcurrentHashMap.md&#10;&#12288; &#9500; DataStructureBST.md&#10;&#12288; &#9500; FileTreeInJava.md&#10;&#12288; &#9500; Grep&#38;RE.md&#10;&#12288; &#9492; HashTable&#38;BloomFilter.md</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="集合类" scheme="http://ningquec.github.io/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[grep与正则表达式]]></title>
    <link href="http://ningquec.github.io/2015/06/26/Grep&RE/"/>
    <id>http://ningquec.github.io/2015/06/26/Grep&RE/</id>
    <published>2015-06-26T12:22:58.000Z</published>
    <updated>2015-07-22T07:45:54.112Z</updated>
    <content type="html"><![CDATA[<p><a href="http://tyroneli.com/2015/06/16/grep-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">上回</a>说到grep与正则表达式关系紧密，今天来详细的谈一谈。</p>
<h2 id="一、简介">一、简介</h2><p>正则表达式，让人不明觉厉，望而却步。但实际上它就相当于数学里的九九乘法表，背会很难，之后做乘法就很快了。<br>正则表达式也是这样的工具，看起来很难，背会了之后大有帮助。乘法表建立了乘法的基础规则，而正则表达式建立了一系列语法的规则。它是用来匹配符合某种语法的字符串，从而可以对这些筛选出来的字符串进行处理。</p>
<p>所以天然的，在Linux中，grep命令经常与正则表达式结合起来执行一些模糊查询或者指向性查询。<br>比如一些常见的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll | grep -E &#34;*.txt&#34;  &#10;    #&#21015;&#20986;&#24403;&#21069;&#36335;&#24452;&#19979;&#30340;txt&#25991;&#20214;&#10;    #-E&#36873;&#39033;&#34920;&#31034;&#20351;&#29992;&#25193;&#23637;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#65292;grep -E&#30456;&#24403;&#20110;egrep&#10;    #&#34;*&#34;&#23601;&#26159;&#19968;&#31181;&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#20803;&#23383;&#31526;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>【注】其实直接使用<code>ll *.txt</code>也能得到相同结果，这是因为Linux直接把*解释为任意的字符串。</p>
<h2 id="二、正则表达式基础">二、正则表达式基础</h2><p>正则表达式是如何建立语法规则的呢？它定义了一系列的元字符（像”*“这样的），通过元字符和其他字符的组合来表达出一种规则，对待匹配文本进行筛选，只有符合这种规则的文本才能被保留下来。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/8028807454817125924.jpg" alt="筛选过程"></p>
<ul>
<li>基本正则表达式所定义的元字符</li>
</ul>
<table><tr><th>元字符</th><th>作用</th><th>例子</th><th>例子说明</th></tr><tr><td>^</td><td>行首定位符</td><td>^ty</td><td>匹配”t”开头，后面紧跟一个”y”的字符串</td></tr><tr><td>$</td><td>行尾定位符</td><td>txt$</td><td>匹配以”t”结尾，前面两个字符是”t””x”的字符串</td></tr><tr><td>.</td><td>单个字符匹配</td><td>s.</td><td>匹配”s”后面有一个字符的字符串</td></tr><tr><td>*</td><td>限定符</td><td>s*</td><td>“*“表示匹配其前导字符若干次，包括0次。这里是匹配有若干个”s”的字符串</td></tr><tr><td>[]</td><td>字符集匹配</td><td>[abc]</td><td>表示匹配”a”,”b”或”c”的字符串</td></tr><tr><td>[^]</td><td>字符集不匹配</td><td>[^abc]</td><td>表示不匹配”a”,”b”,”c”里的任意字符</td></tr><tr><td>()</td><td>子表达式</td><td>([0-9]{2})?</td><td>匹配两个或0个数字</td></tr><tr><td>x{m,n}</td><td>区间表达式</td><td>a{2,3}</td><td>表示”a”重复2~3次</td></tr></table>

<ul>
<li>扩展正则表达式的元字符</li>
</ul>
<table><tr><th>元字符</th><th>作用</th><th>例子</th><th>例子说明</th></tr><tr><td>+</td><td>限定符，同*</td><td>s+</td><td>“+”表示匹配其前导字符若干次，至少1次</td></tr><tr><td>?</td><td>限定符</td><td>ss?</td><td>“?”表示前面的字符可以重复0或1次。这里是一个”s”后面可能再跟一个”s”</td></tr><tr><td>(|)</td><td>括号竖线组合使用表示可选值</td><td>(a|^ym)</td><td>匹配含有”a”或者以”ym”开头的字符串</td></tr></table>


<ul>
<li>POSIX字符集</li>
</ul>
<p>不同国家的字符编码很有可能不同，例如：<br>LANG=C：A B C D … Z a b c d …z<br>LANG=zh_TW：a A b B c C d D … z Z<br>当采用第二种编码时，[A-Z]之间会包括小写字母b-z。所以为了避免这种问题，可以使用POSIX字符集来使用特定的字符类。</p>
<p><table><tr><th>字符类</th><th>说明</th></tr><tr><td>[:alnum:]</td><td>匹配任意一个字母或者数字，等价于A-Za-z0-9</td></tr><tr><td>[:alpha:]</td><td>匹配任意一个字母，等价于A-Za-z</td></tr><tr><td>[:digit:]</td><td>匹配任意一个数字，等价于0-9</td></tr><tr><td>[:lower:]</td><td>匹配小写字母，等价于a-z</td></tr><tr><td>[:upper:]</td><td>匹配大写字母，等价于A-Z</td></tr><tr><td>[:graph:]</td><td>匹配一个看的见的字符，不包括空白字符</td></tr><tr><td>[:print:]</td><td>匹配一个可以打印的字符</td></tr><tr><td>[:blank:]</td><td>匹配空格和tab</td></tr><tr><td>[:space:]</td><td>匹配一个空白字符，包括空格、tab、换行、分页符</td></tr><tr><td>[:punct:]</td><td>匹配一个标点符号</td></tr><tr><td>[:xdigit:]</td><td>匹配一个十六进制数字，即0-9,a-f,A-F</td></tr></table><br>【注意】这些字符类要放在方括号中，才能表示字符集匹配：[[:alnum:]] = [A-Za-z0-9]</p>
<h2 id="三、grep与正则表达式的例子">三、grep与正则表达式的例子</h2><p>(1)简单匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#21305;&#37197;&#31354;&#34892;&#10;egrep &#34;^$&#34; testfile    &#10;&#10;#&#21305;&#37197;&#25152;&#26377;&#33521;&#25991;&#23383;&#31526;&#10;egrep &#34;[a-zA-Z]&#34; testfile&#10;&#10;#&#21305;&#37197;tast&#25110;&#32773;test&#10;egrep &#34;t[ae]st&#34; testfile</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#21305;&#37197;&#20197;&#23383;&#31526;s&#24320;&#22836;&#65292;&#32039;&#36319;&#33509;&#24178;b&#30340;&#25991;&#20214;&#21517;&#10;ll | egrep &#34;^sb*&#34;&#10;&#10;#&#21305;&#37197;txt&#25991;&#20214;&#10;ll | egrep &#34;\.txt$&#34;      #&#36825;&#37324;&#30340;&#34;.&#34;&#38656;&#35201;&#36827;&#34892;&#36716;&#20041;</span><br></pre></td></tr></table></figure>
<p>(2)复杂一些的匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#21305;&#37197;QQ&#21495;&#30721;&#65292;&#31532;&#19968;&#20301;&#19981;&#33021;&#26159;0&#65292;5&#20301;&#20197;&#19978;&#30340;&#25968;&#23383;&#12290;&#10;egrep &#34;[1-9][0-9]&#123;4,&#125;&#34; testfile&#10;&#10;#&#21305;&#37197;IP&#22320;&#22336;&#65292;&#20849;4&#32452;&#25968;&#23383;&#65292;&#29992;&#34;.&#34;&#38548;&#24320;&#10;egrep &#34;^([0-9]&#123;1,2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\.   #&#31532;&#19968;&#32452;&#25968;&#23383;&#10;        ([0-9]&#123;1,2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\.   #&#31532;&#20108;&#32452;&#25968;&#23383;&#10;        ([0-9]&#123;1,2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\.   #&#31532;&#19977;&#32452;&#25968;&#23383;&#10;        ([0-9]&#123;1,2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])$&#34;   #&#31532;&#22235;&#32452;&#25968;&#23383;&#10;        testfile &#10;&#10;#&#21305;&#37197;&#37038;&#31665;&#22320;&#22336;&#10;egrep &#34;^[a-z0-9]([a-z0-9]*[-_]?[a-z0-9]+)*@&#10;       ([a-z0-9]*[-_]?[a-z0-9]+)+[.][a-z]&#123;2,3&#125;([.][a-z]&#123;2&#125;)?$&#34;</span><br></pre></td></tr></table></figure></p>
<p><code>此处注意：</code>区间表达式{}应该写成”\{\}”表示转义，实验中发现加不加”\“转义都能得出正确结果，但是直接使用基本正则表达式（grep不加-E选项）则不行。所以应该是扩展正则表达式中取消了这个需要转义字符的地方。</p>
<h2 id="四、其他">四、其他</h2><p>琐碎的片段：</p>
<ol>
<li>当需要将元字符当作普通字符匹配的时候，需要转移字符”\“，但是当元字符位于”[]”中时，除了”-“或者”^”极少数元字符以外，其它的自动转义为普通字符。</li>
<li>正则表达式从左到右计算，遵循一定的优先级：转义符”\“ &gt; 方括号”[]” &gt; 分组 “()” &gt; 限定符”*,+,?,{}” &gt; 普通字符 &gt; 定位符”^,$” &gt; 或”|”。</li>
<li>匹配同一种字符可能有多种正则表达式的写法。</li>
<li>shell本身不支持正则表达式，但是支持”*”，”?”等通配符。</li>
<li>支持正则表达式的还有sed命令，awk命令。以后可以详述。</li>
<li><b>参考</b>：<br>shell从入门到精通，张春晓等编著；<br><a href="http://linux.vbird.org/linux_basic/0330regularex.php#basic_regexp_char" target="_blank" rel="external">鸟哥的Linux私房菜</a>。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://tyroneli.com/2015/06/16/grep-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">上回</a>说到grep与正则表达式关系紧密，今天来详细的谈一谈。</p>
<h2 id="一、简介">一、简介</h2><p>正则表达式，让人不明觉厉，望而却步。但实际上它就相当于数学里的九九乘法表，背会很难，之后做乘法就很快了。<br>正则表达式也是这样的工具，看起来很难，背会了之后大有帮助。乘法表建立了乘法的基础规则，而正则表达式建立了一系列语法的规则。它是用来匹配符合某种语法的字符串，从而可以对这些筛选出来的字符串进行处理。</p>
<p>所以天然的，在Linux中，grep命令经常与正则表达式结合起来执行一些模糊查询或者指向性查询。<br>比如一些常见的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll | grep -E &#34;*.txt&#34;  &#10;    #&#21015;&#20986;&#24403;&#21069;&#36335;&#24452;&#19979;&#30340;txt&#25991;&#20214;&#10;    #-E&#36873;&#39033;&#34920;&#31034;&#20351;&#29992;&#25193;&#23637;&#30340;&#27491;&#21017;&#34920;&#36798;&#24335;&#65292;grep -E&#30456;&#24403;&#20110;egrep&#10;    #&#34;*&#34;&#23601;&#26159;&#19968;&#31181;&#27491;&#21017;&#34920;&#36798;&#24335;&#30340;&#20803;&#23383;&#31526;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
      <category term="正则表达式" scheme="http://ningquec.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[树（一）：二叉查找树]]></title>
    <link href="http://ningquec.github.io/2015/06/22/DataStructureBST/"/>
    <id>http://ningquec.github.io/2015/06/22/DataStructureBST/</id>
    <published>2015-06-22T07:28:51.000Z</published>
    <updated>2015-07-07T13:45:33.956Z</updated>
    <content type="html"><![CDATA[<h2 id="一、二叉查找树的基本特点">一、二叉查找树的基本特点</h2><blockquote>
<p>二叉查找树的定义：二叉查找树（BST，又叫二叉排序树）是一棵二叉树，其中每一个节点都包含两个指向两个孩子的指针域和一个实现了comparable接口的数据域。并且，每个节点都大于其左子树任意节点，小于右子树中的任意节点。</p>
</blockquote>
<p>抄书完毕，那么为什要建立这样的一个数据结构呢？</p>
<p>玩一个猜数字的游戏，1~64之间（假设目标数字为20）。<br>“1”  “低了”  “2”  “低了”  “3”  “低了”  “4” “低了”……     锲而不舍型要猜上20次。<br>“32”  “高了”  “16”  “低了”  “24”  “高了”  “20”  “答对了”     机智折半型只需要猜4次。<br>无论目标数字如何刁钻，采用折半的策略都能在log_2n次以内猜中。<br>因为这样每一次都能够排除掉一半的可能性，也就是说折半策略每一次都将问题的解空间折半。<br><a id="more"></a><br>把基于比较的排序算法换个角度思考：一串个数为N的数字，排序方式共有N!种，要从中找到唯一的目标序列。<br>同样的，我们把排序的解空间折半:在比较了某两个数字之后立即排除掉一半的排序方式。<br>找到目标序列的次数为log_2(N!)，约等于Nlog_2N。这就是基于比较的排序算法的最优复杂度：O(nlog_2n)。<br>上述第一种猜数字方法就是有序数组中的顺序查找，第二种是二分查找，算法时间复杂度为O(log_2n)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = array.length;</span><br><span class="line">	<span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = len - <span class="number">1</span>;</span><br><span class="line">    whlie(low &lt;= high)&#123;</span><br><span class="line">    	<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    	<span class="keyword">if</span>(key == array[mid])&#123;</span><br><span class="line">    		<span class="keyword">return</span> mid;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; array[mid])&#123;</span><br><span class="line">    		low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有序数组的二分查找已经是采用最优策略的方式了，为什么要引入二叉查找树呢？<br>首先，二叉查找树每个节点都大于其左子树任意节点，小于右子树中的任意节点。查找时，每次比较都至少砍掉了在该节点某一个子树上的可能性，当树平衡的时候，这一点同二分查找是差不多的。<code>当树退化为一棵斜树时不然，查找的复杂度退化为O(n)</code>。<br>其次，二叉查找树拥有二分查找无法企及的优势：插入快速。<br>基于二分查找向空表中插入N个元素的时间复杂度为O(n^2)，而二叉查找树插入操作是时间复杂度约是O(log_2n)，是对数级别的。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/2010062717002636.png" alt="二叉查找树插入图示"></p>
<h2 id="二、二叉查找树的实现">二、二叉查找树的实现</h2><p>1.基本结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">binarySearchTree</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">		<span class="keyword">private</span> Node leftChild;</span><br><span class="line">		<span class="keyword">private</span> Node rightChild;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//见2</span></span><br><span class="line">		<span class="comment">//找到值等于value的节点返回true，否则返回false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//见3</span></span><br><span class="line">		<span class="comment">//查找适合的位置执行插入操作，插入的永远都是叶子节点（树初始为空时为根节点）</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//见4</span></span><br><span class="line">		<span class="comment">//返回删除之后补位的节点，未找到待删除节点返回null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.二叉查找树的查找操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> current = root.value;</span><br><span class="line">	<span class="keyword">if</span>(current &gt; value)&#123;</span><br><span class="line">		<span class="keyword">return</span> get(root.leftChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current &lt; value)&#123;</span><br><span class="line">		<span class="keyword">return</span> get(root.rightChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.二叉查找树的插入操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	root = put(root,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">		Node node = <span class="keyword">new</span> Node(value);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> current = root.value;</span><br><span class="line">	<span class="keyword">if</span>(current &gt; value)&#123;</span><br><span class="line">		root.leftChild = put(root.leftChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current &lt; value)&#123;</span><br><span class="line">		root.rightChild = put(root.rightChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>;<span class="comment">//相等不作操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<em>二叉查找树的删除操作</em><br>首先找到要删除的节点，未找到不执行删除。第一种情况：要删除的节点没有左右子节点，直接删除即可（将父节点指向自身的链接置null）。<br>第二种情况：要删除的节点只有一个子节点，将子节点直接替换自身即可。<br>第三种情况：要删除的节点拥有左右子节点，这种情况比较复杂。基本思路就是删除节点后，用他的直接<code>后继节点</code>填补位置。<br>这个后继节点其实就是二叉查找树中序遍历的直接后继节点，就是其右子树中的最小节点（该节点一定不含有左子节点），这样可以用最小的代价来执行删除。</p>
<ul>
<li>令sonOfX=x的后继节点：min(x.rightChild)</li>
<li>sonOfX.rightChild指向removeMin(x.rightChild)，也就是指向删掉后继节点的x的右子树。</li>
<li>sonOfX.leftChild指向原来x.leftChild。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/IMG_20150623_224106.jpg" alt="删除图示"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(Node root,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> current = root.value;</span><br><span class="line">	<span class="keyword">if</span>(current &gt; value)&#123;</span><br><span class="line">		root.leftChild = remove(root.leftChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current &lt; value)&#123;</span><br><span class="line">		root.rightChild = remove(root.rightChild,value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//找到删除位置</span></span><br><span class="line">		<span class="keyword">if</span>(root.rightChild == <span class="keyword">null</span>) <span class="keyword">return</span> root.leftChild;</span><br><span class="line">		<span class="keyword">if</span>(root.leftChild == <span class="keyword">null</span>) <span class="keyword">return</span> root.rightChild;</span><br><span class="line">		Node sonOfRoot = min(root.rightChild);  <span class="comment">//待删除节点的直接后继节点</span></span><br><span class="line">		sonOfRoot.rightChild = removeMin(root.rightChild);</span><br><span class="line">		sonOfRoot.leftChild = root.leftChild;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sonOfRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">min</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">	<span class="comment">//找出root最小节点</span></span><br><span class="line">	<span class="keyword">if</span>(root.leftChild == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	<span class="keyword">return</span> min(root.leftChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">removeMin</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">	<span class="comment">//删除root子树中最小的节点</span></span><br><span class="line">	<span class="keyword">if</span>(root.leftChild == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> root.rightChild;</span><br><span class="line">	root.leftChild = removeMin(root.leftChild);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、二叉查找树的基本特点">一、二叉查找树的基本特点</h2><blockquote>
<p>二叉查找树的定义：二叉查找树（BST，又叫二叉排序树）是一棵二叉树，其中每一个节点都包含两个指向两个孩子的指针域和一个实现了comparable接口的数据域。并且，每个节点都大于其左子树任意节点，小于右子树中的任意节点。</p>
</blockquote>
<p>抄书完毕，那么为什要建立这样的一个数据结构呢？</p>
<p>玩一个猜数字的游戏，1~64之间（假设目标数字为20）。<br>“1”  “低了”  “2”  “低了”  “3”  “低了”  “4” “低了”……     锲而不舍型要猜上20次。<br>“32”  “高了”  “16”  “低了”  “24”  “高了”  “20”  “答对了”     机智折半型只需要猜4次。<br>无论目标数字如何刁钻，采用折半的策略都能在log_2n次以内猜中。<br>因为这样每一次都能够排除掉一半的可能性，也就是说折半策略每一次都将问题的解空间折半。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
      <category term="数据结构" scheme="http://ningquec.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://ningquec.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[grep 命令详解]]></title>
    <link href="http://ningquec.github.io/2015/06/16/CommandGrep/"/>
    <id>http://ningquec.github.io/2015/06/16/CommandGrep/</id>
    <published>2015-06-16T12:02:13.000Z</published>
    <updated>2015-07-04T09:14:47.677Z</updated>
    <content type="html"><![CDATA[<h2 id="一、简介">一、简介</h2><p>grep: Gloabal Search Regular Expression and Print out the line，意为全局搜索正则表达式并打印文本行。所以<code>1.grep是一个强大的文本搜索工具</code> <code>2.grep与正则表达式联系紧密</code>，之后也会从这两个大的方面来详细介绍。grep命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] pattern [file...]</span><br></pre></td></tr></table></figure></p>
<p>[options]表示选项，具体的命令选项见下表。pattern表示要匹配的模式（包括目标字符串、变量或者正则表达式），file表示要查询的文件名，可以是一个或者多个。pattern后面所有的字符串参数都会被理解为文件名。<br><a id="more"></a></p>
<p><table><tr><th>选项</th><th>说明</th></tr><tr><td>-c</td><td>只打印匹配的文本行的行数，不显示匹配的内容</td></tr><tr><td>-i</td><td>匹配时忽略字母的大小写</td></tr><tr><td>-h</td><td>当搜索多个文件时，不显示匹配文件名前缀</td></tr><tr><td>-n</td><td>列出所有的匹配的文本行，并显示行号</td></tr><tr><td>-l</td><td>只列出含有匹配的文本行的文件的文件名，而不显示具体的匹配内容</td></tr><tr><td>-s</td><td>不显示关于不存在或者无法读取文件的错误信息</td></tr><tr><td>-v</td><td>只显示不匹配的文本行</td></tr><tr><td>-w</td><td>匹配整个单词</td></tr><tr><td>-x</td><td>匹配整个文本行</td></tr><tr><td>-r</td><td>递归搜索，搜索当前目录和子目录</td></tr><tr><td>-q</td><td>禁止输出任何匹配结果，而是以退出码的形式表示搜索是否成功，其中0表示找到了匹配的文本行</td></tr><tr><td>-b</td><td>打印匹配的文本行到文件头的偏移量，以字节为单位</td></tr><tr><td>-E</td><td>支持扩展正则表达式</td></tr><tr><td>-P</td><td>支持Perl正则表达式</td></tr><tr><td>-F</td><td>不支持正则表达式，将模式按照字面意思匹配</td></tr></table></p>
<h2 id="二、grep简单应用场景">二、grep简单应用场景</h2><p>首先介绍一下我的实验环境，在/home/tyrone下建立3个简单的txt文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#----------------------/home/tyrone/text1.txt---------------------&#10;hello world&#10;mailx&#10;uuen&#10;letitia&#10;#----------------------/home/tyrone/text2.txt---------------------&#10;hello world,this is for grep test &#10;#----------------------/home/tyrone/text3.txt---------------------&#10;hello world&#10;tyrone</span><br></pre></td></tr></table></figure></p>
<p>（1）多文件查询，file之间用空格隔开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i &#34;hello world&#34; test1.txt test2.txt&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;test1.txt:hello world&#10;test2.txt:hello world,this is for grep test</span><br></pre></td></tr></table></figure></p>
<p>（2）多模式匹配，模式之间为“逻辑或”的关系，匹配任意一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#26041;&#27861;1&#65306;&#20351;&#29992;-e&#36873;&#39033;&#10;grep -e &#34;hello world&#34; -e &#34;mailx&#34; -r /home/tyrone&#10;&#10;#&#26041;&#27861;2&#65306;&#20351;&#29992;&#27491;&#21017;&#34920;&#36798;&#24335;&#65292;-E&#10;grep -E &#34;hello world|mailx&#34; -r /home/tyrone&#10;&#10;#&#26041;&#27861;3&#65306;&#20351;&#29992;&#27491;&#21017;&#34920;&#36798;&#24335;&#65292;egrep&#65292;&#21516;grep -E&#31561;&#25928;&#10;egrep &#34;hello world|mailx&#34; -r /home/tyrone</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#36755;&#20986;&#32467;&#26524;&#22343;&#30456;&#21516;&#65306;&#10;/home/tyrone/test1.txt:hello world&#10;/home/tyrone/test1.txt:mailx&#10;/home/tyrone/test2.txt:hello world,this is for grep test&#10;/home/tyrone/test3.txt:hello world</span><br></pre></td></tr></table></figure>
<p>（3）多模式匹配，模式之间为“逻辑与”的关系，匹配所有模式。<br>这个问题我查阅了很多方法，并逐一试验了一下。基本思想大致相同：先匹配一个模式，然后grep下面一个模式，将前一次grep的结果作为要查询文件路径依次向后传递。<code>注意：前一次grep的结果必须加上-l选项，否则会把匹配成功的文件内容作为要查询的文件名向后传递</code>。我希望做到的是能够显示出同时包含模式的文件，并且跟随显示匹配每个模式的内容。可惜我现在找到的方法都仅仅能够显示匹配最后一个模式的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#26041;&#27861;1&#65306;&#27604;&#36739;&#31528;&#65292;&#23558;&#20854;&#25353;&#19968;&#27425;&#30340;&#32467;&#26524;&#37325;&#23450;&#21521;&#21040;&#19968;&#20010;&#25991;&#20214;&#65292;&#28982;&#21518;xargs grep&#26469;&#20381;&#27425;&#35835;&#21462;&#12290;&#10;grep -i &#34;hello world&#34; -rl /home/tyrone &#62;&#62; reslut.txt&#10;cat result.txt | xargs grep -i &#34;mailx&#34; &#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;/home/tyrone/test1.txt:mailx</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#26041;&#27861;2&#65306;&#30452;&#25509;&#21033;&#29992;&#31649;&#36947;&#10;grep -i &#34;hello world&#34; -rl /home/tyrone | xargs grep -i &#34;mailx&#34;&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;/home/tyrone/test1.txt:mailx</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#26041;&#27861;3&#65306;&#20351;&#29992;find&#65292;&#36866;&#21512;&#20110;&#38656;&#35201;&#28789;&#27963;&#21028;&#26029;&#26465;&#20214;&#30340;&#22330;&#26223;&#12290;&#20363;&#22914;&#26597;&#25214;&#25351;&#23450;&#36335;&#24452;&#19979;&#65292;&#21516;&#26102;&#21305;&#37197;&#22810;&#20010;&#27169;&#24335;&#30340;txt&#25991;&#20214;&#12290;&#27880;&#24847;&#65306;&#26412;&#20363;&#20013;&#8220;mailx&#8221;&#21518;&#38754;&#30340;&#21629;&#20196;&#24517;&#39035;&#21152;&#19978;&#21453;&#24341;&#21495; ` &#65292;&#21542;&#21017;&#20250;&#34987;&#24403;&#20316;&#35201;&#26597;&#35810;&#30340;&#25991;&#20214;&#21517;&#12290;&#10;grep -i &#34;mailx&#34; `find /home/tyrone -type f -name &#34;*.txt&#34; -exec grep -l &#34;hello world&#34;  &#123;&#125; \;`&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;/home/tyrone/test1.txt:mailx</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#26041;&#27861;4:&#21516;3&#10;find /home/tyrone -name &#34;*.txt&#34; -exec grep -l &#34;hello world&#34; &#123;&#125; \; | xargs grep -i &#34;mailx&#34;&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;/home/tyrone/test1.txt:mailx</span><br></pre></td></tr></table></figure>
<p>最后不得不感慨一下linux命令的组合方式，能像积木一样堆积出无穷的组合，是时候展现真正的想象力了。。。<br>（4）查找指定用户的进程<br>ps是查看当前进程的指令，e表示所有进程，f表示全格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep &#34;tyrone&#34;&#10;&#10;#&#36755;&#20986;&#32467;&#26524;&#10;root      27200  1827  0 Jun15 ?        00:00:00 sshd: tyrone [priv]&#10;tyrone    27434 27433  0 Jun15 pts/50   00:00:00 -bash&#10;tyrone    43316 27434  2 02:14 pts/50   00:00:00 ps -ef&#10;tyrone    43317 27434  0 02:14 pts/50   00:00:00 grep tyrone</span><br></pre></td></tr></table></figure></p>
<h2 id="三、团结就是力量">三、团结就是力量</h2><p>现在要搞一个脚本把前面总结的命令一锅炖了。先搜索同时匹配多个模式的文件，把它们先备份之后，替换目标字符串：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#----------------------/home/tyrone/myshell.ksh---------------------&#10;#! /bin/ksh&#10;&#10;grep &#34;hello world&#34; -rl /home/tyrone | xargs grep -l &#34;mailx&#34; &#62; /home/tyrone/result5.txt&#10;cat result5.txt | while read line&#10;do&#10;    cp $&#123;line&#125; $&#123;line&#125;.bak20150616&#10;    sed -i &#34;s/hello world/letitia/g&#34; `grep &#34;hello world&#34; -rl $&#123;line&#125;`&#10;done</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#36755;&#20986;&#32467;&#26524;&#65306;&#21482;&#26377;test1.txt&#28385;&#36275;&#26465;&#20214;&#65292;&#23558;&#34;hello world&#34;&#26367;&#25442;&#25104;&#20102;&#34;letitia&#34;&#10;#&#21734;&#23545;&#20102;&#12290;&#12290;&#36824;&#26377;&#25105;&#30340;shell&#25991;&#20214;&#20063;&#21516;&#26102;&#21253;&#21547;&#20102;&#36825;&#20004;&#20010;&#27169;&#24335;&#65292;&#21487;&#20197;&#36890;&#36807;find&#38480;&#23450;&#25991;&#20214;&#21518;&#32512;&#65292;&#19981;&#34920;&#10;#----------------------/home/tyrone/text1.txt---------------------&#10;letitia&#10;mailx&#10;uuen&#10;letitia&#10;#----------------------/home/tyrone/text2.txt---------------------&#10;hello world,this is for grep test &#10;#----------------------/home/tyrone/text3.txt---------------------&#10;hello world&#10;tyrone&#10;#----------------/home/tyrone/text1.txt.bak20150616---------------&#10;hello world&#10;mailx&#10;uuen&#10;letitia</span><br></pre></td></tr></table></figure>
<h2 id="四、下回分解">四、下回分解</h2><p>grep与正则表达式的故事</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、简介">一、简介</h2><p>grep: Gloabal Search Regular Expression and Print out the line，意为全局搜索正则表达式并打印文本行。所以<code>1.grep是一个强大的文本搜索工具</code> <code>2.grep与正则表达式联系紧密</code>，之后也会从这两个大的方面来详细介绍。grep命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] pattern [file...]</span><br></pre></td></tr></table></figure></p>
<p>[options]表示选项，具体的命令选项见下表。pattern表示要匹配的模式（包括目标字符串、变量或者正则表达式），file表示要查询的文件名，可以是一个或者多个。pattern后面所有的字符串参数都会被理解为文件名。<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hash表与bloom filter]]></title>
    <link href="http://ningquec.github.io/2015/06/13/HashTable&BloomFilter/"/>
    <id>http://ningquec.github.io/2015/06/13/HashTable&BloomFilter/</id>
    <published>2015-06-13T06:02:43.000Z</published>
    <updated>2015-07-12T03:16:02.239Z</updated>
    <content type="html"><![CDATA[<p>如果想要快速存取一串小整数，可以用一个数组来存储。将整数的值作为它们在数组中的索引位置，这样就可以在O(1)的时间内快速访问任何一个整数。<br>在日常开发中，我们常常会遇到更加复杂的问题：判断某个对象是否存在于某个集合中。例如在字处理时，判断字是否拼写正确（也就是判断它是否在已知的字典中）；在网络爬虫中，判断某个URL是否被访问过等等。在计算机中，我们通常用hash表来处理这一类问题。<br>hash表是前面所述数组的扩展，通过一系列算术操作（伪随机性函数）将对象转换为数组的索引位置，据此来实现在O(1)时间访问数组中的对象。</p>
<h2 id="一、hash函数的选择">一、hash函数的选择</h2><p>(1)hash函数的目的是将对象转换为数组的索引。如何选择好的hash函数呢？有一条最重要的规则：<code>保证均匀性</code>。<br>即一个好的hash函数要能够将对象均匀的映射到数组中，保证均匀性的最好方法也许就是保证对象的每一位都参与hash值的运算。<br>这段程序是String类型hash值计算的简单实现，Java中的String类型默认使用了近似的方法。<br>可以看到，程序中将str的每一位都参与到hash值的运算中。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hash = <span class="number">0</span>；</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">		hash = (R * hash + s.charAt(i)) % M</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在下图中，选择了这种String类型的hashcode()方法，将《双城记》中10679个单词大致均匀地分布到97个位置上。</p>
<p><img src="http://7xjnnt.com1.z0.glb.clouddn.com/IMG_20150613_173847.JPG" alt="双城记hash图"><br>Java针对每一种数据类型都继承了一个能返回32位整数的hashcode()方法，可以直接调用来完成对象到值的映射。<br>因为我们需要的是数组的索引而不是32位的整数，所以在实现中会将默认的hashcode()方法同取余结合起来产生一个0到M-1的整数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将hashcode()返回值转化为M长度的数组索引</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x.hashcode() &amp; <span class="number">0x7fffffff</span>) % M    </span><br><span class="line">	<span class="comment">//先令hashcode()的结果同0x7fffffff相与，将32位整数转换为31位的非负整数（屏蔽符号位）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Java中自定义的对象，你可以试着自己重写hashcode()方法。但要记住一点：同时重写hashcode()方法和equals()方法。<br>因为默认情况下，<code>每一种数据类型的hashcode()方法都必须和equals()方法保持一致。</code>如果a.equals(b)返回true，那么a.hashcode()的返回值必然和b.hashcode()的返回值相同。<br>相反，如果两个对象的hashcode()方法返回值不同，那么我们知道这两个对象是不同的。但如果两个对象的hashcode()方法返回值相同，这两个对象也可能不同，我们需要继续通过equals()方法来判断。</p>
<h2 id="二、处理碰撞问题">二、处理碰撞问题</h2><p>hash算法的第二步是<code>碰撞处理</code>。当两个不同的对象经过hash函数处理之后，可能会得出相同hash值。<br>一种直接的方法是将大小为M的数组中的每个元素指向一个链表，同一个链表中的节点存储hash值相同的对象。如图。为了保证均匀性，M条链表存储N个节点时候，要保证链表的平均长度约为N/M。<br>Java中的集合类<a href="http://tyroneli.com/2015/07/11/CollectionHashMap/" target="_blank" rel="external">HashMap</a>，HashTable和ConcurrentHashMap均采用了这种方法。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/6368753e-12ad-39ac-a72e-06981c316425.png" alt="拉链法图示"><br>解决碰撞问题的另外一种方式就是用大小M的数组保存N个对象，其中M&gt;N，利用数组中的空白位置来解决碰撞。<br>当碰撞发生的时候，我们直接检查数组下一个为空的位置，将其作为对象的索引位置。这样的方法叫做线性探测法。</p>
<h2 id="三、hash表的效率问题探究">三、hash表的效率问题探究</h2><p>hash表的平均时间复杂度是O(1)，这是它的优点之一，这里主要讨论hash表所需的空间大小。假设有一个大小为M的使用线性探测法的散列表，其中N个位置存储了对象(M&gt;N)。命中和未命中的查找所需的探测次数分别为：（这个公式我想了很久，可是没有证明出来，求大神指导）<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/图片1.png"><br>由公式可知，当装载因子a=N/M趋近于1的时候，探测次数大大增加，精确度严重下降，不能保证在O(1)的时间内完成存取。同时要兼顾hash表存储空间的利用效率，<code>一般保证其装载因子在1/2左右</code>，探测的预计次数在1.5到2.5之间。</p>
<h2 id="四、bloom_filter的原理">四、bloom filter的原理</h2><p>hash表的存储效率一般只有50%，那么在大数据量环境下想要快速判断对象是否在集合中就显得不太合适了。<br>比如在过滤垃圾邮件时，一种方法就是用hash表记录下那些垃圾邮件的地址，然后判断那些邮件发件人地址是否在表内。由于发送者不断注册新的地址，全球少说也有几十亿的地址。<br>假设采用8个字节来标记一个地址，一亿个地址需要0.8GB来存储，放在散列表中就需要1.6GB。因此，一般的服务器不可能存储几十亿个地址。<br>1970年，Burton Bloom提出了一种叫bloom filter的数学工具，它在执行hash表职责的同时仅仅需要hash表1/8到1/4的大小。bloom filter实际上是一个很长的二进制向量和一系列随机映射函数，下面说明它的工作原理。<br>假定要存储一亿个垃圾邮件地址的黑名单，先建立一个16亿个比特位即两亿字节的向量，然后将这16亿个比特位全部清零。对于每一个电子邮件地址X，用8个不同的随机数产生器(F1,F2,F3,F4,F5,F6,F7,F8)产生8个信息指纹(f1,f2,f3,f4,f5,f6,f7,f8)。<br>再用一个随机数产生器G把这8个信息指纹映射到1——16亿中的8个位置。现在把这8个位置的比特位全部置为1。对这一亿个垃圾邮件地址都进行这样的处理之后（如果某一位已经是1，保持不变），一个针对这些电子邮件地址的bloom filter就建成了，见下图。<br><img src="http://7xjnnt.com1.z0.glb.clouddn.com/1590333618416425145.jpg" alt="bloom filter图示"><br>现在就可以利用bloom filter来检测一个可疑的电子邮件地址Y是否在黑名单中。用同样的8个随机数产生器(F1,F2,F3,F4,F5,F6,F7,F8)产生8个信息指纹(f1,f2,f3,f4,f5,f6,f7,f8)，然后将这8个指纹映射到8个比特位上。<br>如果Y在黑名单中，那么这8位一定是1。<code>bloom filter不会漏掉黑名单中任何一个可以地址，但是它也可能产生误判。</code><br>想像这样一个场景：一个正常的地址经过8个的随机数产生器，映射的8个位置上正好全被其它垃圾邮件置为1，按照规则正常的地址也被过滤掉了。<br>所幸这样的概率很低，在上面的例子中，误识别率在万分之一以下。我们可以建立一个小的白名单来存储那些容易误判的地址。</p>
<h2 id="五、大数据环境下bloom_filter的应用">五、大数据环境下bloom filter的应用</h2><p>在我今年4月份找实习的过程中，BAT都非常喜欢问海量数据问题，bloom filter是其中一个很常用的方法。<br>【例子】给定a、b两个文件，各存放20亿个URL，每个URL各占64个字节，内存限制是4G，请找出共同的URL。<br>在回答这道题之前，最好向面试官询问是否允许一定的误识别率，然后决定是否使用bloom filter。4G内存大约可以表示340亿比特位，将其中一个文件中的20亿URL映射为160亿比特位（装载因子大概在0.48左右），然后遍历另一个文件，判断每一个URL映射的比特位是否都已经被置为1。</p>
<h2 id="六、参考书籍">六、参考书籍</h2><p>（1）数学之美。吴军著<br>（2）算法。Robert Sedgewick,Kevin Wayne著，谢路云译</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果想要快速存取一串小整数，可以用一个数组来存储。将整数的值作为它们在数组中的索引位置，这样就可以在O(1)的时间内快速访问任何一个整数。<br>在日常开发中，我们常常会遇到更加复杂的问题：判断某个对象是否存在于某个集合中。例如在字处理时，判断字是否拼写正确（也就是判断它是否在已知的字典中）；在网络爬虫中，判断某个URL是否被访问过等等。在计算机中，我们通常用hash表来处理这一类问题。<br>hash表是前面所述数组的扩展，通过一系列算术操作（伪随机性函数）将对象转换为数组的索引位置，据此来实现在O(1)时间访问数组中的对象。</p>
<h2 id="一、hash函数的选择">一、hash函数的选择</h2><p>(1)hash函数的目的是将对象转换为数组的索引。如何选择好的hash函数呢？有一条最重要的规则：<code>保证均匀性</code>。<br>即一个好的hash函数要能够将对象均匀的映射到数组中，保证均匀性的最好方法也许就是保证对象的每一位都参与hash值的运算。<br>这段程序是String类型hash值计算的简单实现，Java中的String类型默认使用了近似的方法。<br>可以看到，程序中将str的每一位都参与到hash值的运算中。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://ningquec.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[find命令拾遗]]></title>
    <link href="http://ningquec.github.io/2015/06/11/CommandFind/"/>
    <id>http://ningquec.github.io/2015/06/11/CommandFind/</id>
    <published>2015-06-11T12:42:55.000Z</published>
    <updated>2015-06-17T12:33:02.535Z</updated>
    <content type="html"><![CDATA[<p>上一篇中总结了find命令的简单用法，觉得足够用了，刚过两天脚本中看不懂的find就一个个跳出来。所以将这些放在拾遗里面，也许会有再拾遗，甚至是拾遗又见拾遗。。。。进无止境进无止境。。。</p>
<h3 id="（1）-maxdepth的用法">（1）-maxdepth的用法</h3><p>-maxdepth和-mindepth可以限制搜索的深度。当搜索文件超过某个级别或者搜索过多的目录，会导致查找速度变慢，查找花费的时间过多，这时候就可以用-maxdepth来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -maxdepth 1 -name &#34;*.csv&#34; -mtime -5 | wc -l</span><br></pre></td></tr></table></figure></p>
<p>本例表示只在/home目录下查找最后修改时间在5天以内的csv文件，并统计文件的数目。如果修改为<code>-maxdepth 2</code>就表示在/home目录及其一级子目录下查找，不会搜索到/home/sub/sub1目录下。-mindepth的意义同-maxdepth相反，此处不赘述。<br><a id="more"></a></p>
<h3 id="（2）-depth的用法和find结果的排列顺序">（2）-depth的用法和find结果的排列顺序</h3><p>在你想要批量备份文件的时候，总希望先备份所有的文件，再备份子目录下的文件，这里需要考虑如何find出想要备份文件的顺序。<br>-depth可以在处理目录以前首先处理目录下的子内容。以下查询显示了使用-depth的效果：<br>第一个例子：不使用depth，使用通配符*搜索当前目录下的file和directory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find *</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#36755;&#20986;&#32467;&#26524;&#65306;&#10;chmod&#10;result.txt&#10;sasuser.v94&#10;sasuser.v94/regstry.sas7bitm&#10;sasuser.v94/parms.sas7bcat&#10;zhnlicron</span><br></pre></td></tr></table></figure>
<p>第二个例子：使用depth，使用通配符*搜索当前目录下的file和directory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find * -depth</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#36755;&#20986;&#32467;&#26524;&#10;chmod&#10;result.txt&#10;sasuser.v94/regstry.sas7bitm&#10;sasuser.v94/parms.sas7bcat&#10;sasuser.v94&#10;zhnlicron</span><br></pre></td></tr></table></figure>
<p>可以看到/sasuser和它的子目录中的文件位置做了调换。<code>find * -depth</code>会先输出/sasuser目录下的文件。<br>那么问题来了，在不考虑depth的情况下，find是按照什么顺序来输出结果呢？如上第一个例子使用了*通配符，所以默认会先按照字典序来匹配，在进行find操作。<br>比如*会先匹配到当前目录下的./chmod，然后再find ./chmod，所以find出来的结果是按照字典序的。<br>我们再做一个find操作，不使用通配符*直接进行find当前目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#36755;&#20986;&#32467;&#26524;&#10;chmod&#10;zhnlicron&#10;result.txt&#10;sasuser.v94&#10;sasuser.v94/regstry.sas7bitm&#10;sasuser.v94/parms.sas7bcat</span><br></pre></td></tr></table></figure>
<p>位置再次发生了变化，至少表面上看不可能是按照字典序了，那么是依照什么规则呢？这种则涉及到linux中文件名在超级块中的存储方式（spuer_block）：<br>为了快速找到一个文件，我们通常会使用hash算法，和B树算法(二叉树算法)在超级块存储文件名（与inode对应），find操作就是根据B树遍历查找的。<br>在不同的机器中，文件挂到B树上的方式不同，可能遍历查找的结果就会不同。比如以左遍历挂文件名，右遍历来查找文件名。<a href="http://zhidao.baidu.com/link?url=NAUEjiIu4G3CZZRppd_TKmxJgG4WQ77lrx4cp0cNXiNb82nBSINyPZTrCEQJ1E99U3LQgUK4OsILV3LCWEkMkq" target="_blank" rel="external">参考资料</a></p>
<h3 id="（3）使用多个{}的例子">（3）使用多个{}的例子</h3><p>继续上面提出的备份问题，我们已经按照顺序把需要的文件find出来了，需要批量备份成*.bak文件。可以利用{}这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &#34;*.txt&#34; -exec cp &#123;&#125; &#123;&#125;.bak \;&#10;    #&#27880;&#24847;&#25324;&#21495;&#20043;&#38388;&#30340;&#31354;&#26684;&#12290;&#10;    #&#25209;&#37327;&#23558;&#24403;&#21069;&#30446;&#24405;&#19979;&#21518;&#32512;&#20026;txt&#30340;&#25991;&#20214;&#22791;&#20221;&#19968;&#20221;txt.bak&#25991;&#20214;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）-perm的用法">（4）-perm的用法</h3><p><a href="http://tyroneli.com/2015/06/10/find%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/#more" target="_blank" rel="external">上一篇</a>将find操作用于定时crontab任务，来执行change group的操作。其实可以用-perm来更准确的定位到需要修改权限的文件。-perm的用法有以下几种简单的形式：</p>
<ul>
<li>find -perm mode</li>
<li>find -perm -mode</li>
<li>find -perm +mode<br>mode表示严格匹配，-mode表示find权限大于等于mode的文件，+mode表示find权限小于等于mode的文件（可能跟正常的认识刚好相反）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -perm -g=r -type f -exec ll &#123;&#125; \;&#10;    #&#25214;&#21040;&#20855;&#26377;&#32452;&#35835;&#26435;&#38480;&#30340;&#25991;&#20214;&#65292;&#29992;ll&#21629;&#20196;&#26174;&#31034;&#25991;&#20214;&#35814;&#32454;&#20449;&#24687;&#12290;&#10;find . -perm -744;&#10;    #&#25214;&#21040;&#26435;&#38480;&#22823;&#20110;&#31561;&#20110;744&#30340;&#25991;&#20214;&#12290;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>【权限的数字表示】使用ll命令可以查看文件的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /home/tyrone&#10;#&#26174;&#31034;&#32467;&#26524;&#10;-rw-rw-r-- 1 tyrone tyrone   199 Jun  9 20:02 autoexec.sas&#10;-rw-rw-r-- 1 tyrone tyrone     0 Jun  4 01:42 chmod&#10;-rw------- 1 tyrone tyrone     0 Jun  9 19:36 nohup.out&#10;-rw-rw-r-- 1 tyrone tyrone 70429 Jun 10 22:10 resultOfNas.txt&#10;drwxrwxr-x 2 tyrone tyrone  4096 Jun  9 23:11 sasuser.v94&#10;-rw-rw-r-- 1 tyrone tyrone     0 Jun  5 02:13 tyronecron</span><br></pre></td></tr></table></figure></p>
<p>最左边是一串字母和-的集合，从第二列开始每三个一组，分别表示文件所属用户、所属组、组外用户的权限。r代表读，w代表写，x代表执行。例如<code>-rw-rw-r--</code>就表示文件所属用户和所属组对该文件有读写权限，组外只有读的权限。<br>那么怎么对应于数字呢？其中，r=4，w=2，x=1，然后每三个字母一组把数字加起来的和组成一个三位数字。例如<code>-rw-rw-r--</code>就等于<code>-420420400</code>，化为三位数字664即为权限所对应的值。</p>
<h2 id="结语">结语</h2><p>Linux命令很不容易记住，就像散落一地的珍珠，本系列旨在能够不间断的捡起一些，串在一起。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇中总结了find命令的简单用法，觉得足够用了，刚过两天脚本中看不懂的find就一个个跳出来。所以将这些放在拾遗里面，也许会有再拾遗，甚至是拾遗又见拾遗。。。。进无止境进无止境。。。</p>
<h3 id="（1）-maxdepth的用法">（1）-maxdepth的用法</h3><p>-maxdepth和-mindepth可以限制搜索的深度。当搜索文件超过某个级别或者搜索过多的目录，会导致查找速度变慢，查找花费的时间过多，这时候就可以用-maxdepth来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -maxdepth 1 -name &#34;*.csv&#34; -mtime -5 | wc -l</span><br></pre></td></tr></table></figure></p>
<p>本例表示只在/home目录下查找最后修改时间在5天以内的csv文件，并统计文件的数目。如果修改为<code>-maxdepth 2</code>就表示在/home目录及其一级子目录下查找，不会搜索到/home/sub/sub1目录下。-mindepth的意义同-maxdepth相反，此处不赘述。<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[find命令详解]]></title>
    <link href="http://ningquec.github.io/2015/06/10/CommandFind2/"/>
    <id>http://ningquec.github.io/2015/06/10/CommandFind2/</id>
    <published>2015-06-10T13:21:53.000Z</published>
    <updated>2015-06-17T12:33:03.519Z</updated>
    <content type="html"><![CDATA[<h2 id="1-find命令简介">1.<em>find命令简介</em></h2><p>find命令主要用于文件搜索，它的功能非常强大，可以根据不同的标准搜索任何文件，可以在任何位置进行检索。find命令的主要格式如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find path test action</span><br></pre></td></tr></table></figure></p>
<p>（1）path表示要搜索的路径，可以同时指定多个路径，路径之间以空格隔开：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /user/bin              #&#25628;&#32034;/user/bin&#30446;&#24405;&#21644;&#23376;&#30446;&#24405;&#10;find /                      #&#25628;&#32034;&#26681;&#30446;&#24405;&#21450;&#23376;&#30446;&#24405;&#65288;&#23454;&#38469;&#19978;&#23601;&#26159;&#25628;&#32034;&#25972;&#20010;&#25991;&#20214;&#31995;&#32479;&#65289;&#10;find .                      #&#25628;&#32034;&#24403;&#21069;&#30446;&#24405;&#10;find -root                  #&#25628;&#32034;root&#29992;&#25143;&#30340;&#20027;&#30446;&#24405;&#10;find /user/bin /home        #&#25628;&#32034;/user/bin&#21644;/home&#30446;&#24405;&#21450;&#23427;&#20204;&#30340;&#23376;&#30446;&#24405;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>（2）test表示测试条件，用户可以指定多个测试条件来查找符合特定标准的文件，条件之间以空格隔开：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type f              #&#25628;&#32034;&#30340;&#25991;&#20214;&#31867;&#22411;&#65306;f=file d=directory&#10;find / -name &#34;*.txt&#34;        #&#25628;&#32034;&#25991;&#20214;&#21517;&#21518;&#32512;&#20026;txt&#65292;*&#20026;&#36890;&#37197;&#31526;</span><br></pre></td></tr></table></figure></p>
<p>下面是详细测试条件表：</p>
<p><table><tr><th>条件</th><th>说明</th></tr><tr><td><em><b>-name pattern</b></em></td><td>表示包含指定匹配模式的文件名，区分大小写</td></tr><tr><td>-iname pattern</td><td>表示包含指定匹配模式的文件名，不区分大小写</td></tr><tr><td><em><b>-type</b></em></td><td>指定文件类型</td></tr><tr><td>-perm mode</td><td>匹配权限被设置为指定mode的文件</td></tr><tr><td>-user userid</td><td>匹配所有者为指定用户id的文件</td></tr><tr><td>-group groupid</td><td>匹配所有者的主组为指定组id的文件</td></tr><tr><td>-size size</td><td>匹配大小为size的文件</td></tr><tr><td>-empty</td><td>匹配空文件</td></tr><tr><td>-amin [-+]n</td><td>文件最后一次访问时间，-n表示访问时间为距今n分钟以内，+n表示访问时间为距今n分钟以前，n表示恰好n分钟</td></tr><tr><td>-atime [-+]n</td><td>文件最后一次访问时间，时间单位为天</td></tr><tr><td>-cmin [-+]n</td><td>文件最后一次状态改变的时间，时间单位为分钟</td></tr><tr><td>-ctime [-+]n</td><td>文件最后一次状态改变的时间，时间单位为天</td></tr><tr><td>-mmin [-+]n</td><td>文件最后一次被修改的时间，时间单位为分钟</td></tr><tr><td>-mtime [-+]n</td><td>文件最后一次被修改的时间，时间单位为天</td></tr><br></table><br>（3）action表示对find结果执行操作。</p>
<p><table><tr><th>动作</th><th>说明</th></tr><tr><td>-print</td><td>默认动作，将结果写入到标准输出</td></tr><tr><td>-fprint file</td><td>将结果写入到文件file</td></tr><tr><td>-ls</td><td>以详细格式显示搜索结果</td></tr><tr><td>-fls file</td><td>将详细格式的结果写入到文件file</td></tr><tr><td>-delete</td><td>将搜索到的文件删除</td></tr><tr><td><em><b>-exec command {} \;</b></em></td><td>查找并执行命令，{}表示搜索到的文件名</td></tr><tr><td>-ok command {} \;</td><td>查找并执行命令，但是需要用户确认</td><br></tr></table><br>-exec非常实用，使find命令对搜索结果中的文件执行指定的shell命令，其中command表示shell命令，大括号{}表示搜索结果中的文件名，最后的分号表示命令的结束，分号需要使用反斜线转义。注意其中的空格。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -type f -mmin +5 -exec rm &#123;&#125; \;                 &#10;    #&#25214;&#20986;&#24403;&#21069;&#30446;&#24405;&#19979;&#26368;&#21518;&#19968;&#27425;&#22312;5&#20998;&#38047;&#20197;&#21069;&#20462;&#25913;&#36807;&#30340;&#25991;&#20214;&#24182;&#21024;&#38500;&#12290;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-find命令的应用场景">2.<em>find命令的应用场景</em></h2><h3 id="（1）_使用find查找文件中包含指定字符串hello_world的txt或者sh文件">（1） 使用find查找文件中包含指定字符串hello world的txt或者sh文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -type f -name &#34;*.sh&#34; -o -name &#34;*.txt&#34; -exec grep -i &#34;hello world&#34; &#123;&#125; \+;&#10;    # &#27880;&#24847;&#123;&#125;&#20004;&#31471;&#30340;&#31354;&#26684;&#12290;&#10;    # &#8220;+&#8221;&#21495;&#30340;&#20316;&#29992;&#65306;&#21487;&#20197;&#25171;&#21360;&#20986;&#35814;&#32454;&#32467;&#26524;&#65292;&#21253;&#25324;&#21305;&#37197;&#25991;&#20214;&#21517;&#21644;&#21305;&#37197;&#34892;&#20869;&#23481;&#10;    # or&#65306;&#36923;&#36753;&#25110;&#65292;&#22312;&#21629;&#20196;&#20013;&#29992;&#8220;-o&#8221;&#34920;&#31034;&#12290;&#26412;&#20363;&#20013;&#34920;&#31034;sh&#25991;&#20214;&#25110;&#32773;txt&#25991;&#20214;&#37117;&#28385;&#36275;&#27979;&#35797;&#26465;&#20214;&#12290;&#10;    # and&#65306;&#36923;&#36753;&#19982;&#65292;&#31995;&#32479;&#40664;&#35748;&#36873;&#39033;&#65292;&#27979;&#35797;&#26465;&#20214;&#20043;&#38388;&#20197;&#31354;&#26684;&#38548;&#24320;&#21363;&#21487;&#12290;&#10;    # not &#65306;&#36923;&#36753;&#38750;&#65292;&#22312;&#21629;&#20196;&#20013;&#29992;&#8220;&#65281;&#8221;&#34920;&#31034;&#65292;&#20363;&#22914;:&#10;    find ./ ! -name &#34;*.sh&#34;</span><br></pre></td></tr></table></figure>
<p>那么能不能使用管道来实现呢？例如下面这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -type f -name &#34;*.sh&#34; -o -name &#34;*.txt&#34; | grep -i &#34;hello world&#34;&#10;    #&#19981;&#33021;&#24471;&#21040;&#32467;&#26524;&#12290;</span><br></pre></td></tr></table></figure></p>
<p>这样无法想要的结果，因为管道会把find的结果作为输入赋给grep命令，这些结果只是文件名组成的字符串而不是文件的内容。</p>
<h3 id="（2）_搭配xargs解决参数列太长导致溢出的错误">（2） 搭配xargs解决参数列太长导致溢出的错误</h3><p>参考资料：<a href="http://czmmiao.iteye.com/blog/1949225" target="_blank" rel="external">Xargs用法详解(原创)</a></p>
<p>在使用find命令的-exec选项处理匹配到的文件时，find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现 溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。<br>可以把匹配到的文件传递给xargs命令，而<strong><em>xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。</em></strong><br>在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。<br>并且，xargs可以把管道传来的字符串当作文件去执行，这样就解决了（1）中的问题。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -type f -name &#34;*.sh&#34; -o -name &#34;*.txt&#34; | xargs grep -i &#34;hello world&#34;</span><br></pre></td></tr></table></figure></p>
<p>xargs就是为了能对find搜索到的文件进行操作而编写的，还有很多其他的用途，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -perm -7 -print | xargs chmod o-w  &#10;    #&#22312;&#24403;&#21069;&#30446;&#24405;&#19979;&#26597;&#25214;&#25152;&#26377;&#29992;&#25143;&#20855;&#26377;&#35835;&#12289;&#20889;&#21644;&#25191;&#34892;&#26435;&#38480;&#30340;&#25991;&#20214;&#65292;&#24182;&#25910;&#22238;&#30456;&#24212;&#30340;&#20889;&#26435;&#38480;&#12290;&#10;find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz&#10;    #&#26597;&#25214;&#25152;&#26377;&#30340;jpg &#25991;&#20214;&#65292;&#24182;&#19988;&#21387;&#32553;&#23427;&#12290;&#10;find ~ -name &#8216;*.log&#8217; -print0 | xargs -i -0 rm -f &#123;&#125;&#10;    #&#23581;&#35797;&#29992;rm&#21024;&#38500;&#22826;&#22810;&#30340;&#25991;&#20214;&#65292;&#20320;&#21487;&#33021;&#24471;&#21040;&#19968;&#20010;&#38169;&#35823;&#20449;&#24687;&#65306;/bin/rm Argument list too long&#12290;&#29992;xargs&#21435;&#36991;&#20813;&#36825;&#20010;&#38382;&#39064;&#12290;&#10;ls *.jpg | xargs -n1 -i cp &#123;&#125; /external-hard-drive/directory&#10;    #&#25335;&#36125;&#25152;&#26377;&#30340;&#22270;&#29255;&#25991;&#20214;&#21040;&#19968;&#20010;&#22806;&#37096;&#30340;&#30828;&#30424;&#39537;&#21160;&#12290;</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）_统计目录中全部的文件数量及子目录数量。">（3） 统计目录中全部的文件数量及子目录数量。</h3><p>例如以下的shell脚本：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#65281; /bin/bash&#10;&#10;files=&#39;find /etc -type f -print | wc -l&#39;&#10;    #&#32479;&#35745;&#25991;&#20214;&#25968;&#37327;&#10;directories=&#39;find /etc -type d -print | wc -l&#39;&#10;    #&#32479;&#35745;&#23376;&#30446;&#24405;&#25968;&#37327;&#10;    echo &#34;There are $files regular files in /etc dictionary.&#34;   &#10;    echo &#34;There are $directinories directinories in /etc dictionary.&#34;&#10;    #&#36755;&#20986;&#32479;&#35745;&#32467;&#26524;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）_设置crontab任务。">（4） 设置crontab任务。</h3><p>工作里很多task都要在服务器上进行，很难清晰的记录到每一个自己所生成修改的文件，其中的权限问题可能会对其他人产生一些困扰。我们可以设置crontab任务，定时的修改自己文件所属的组或者文件的权限来控制此问题。例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 05 * * * find /path -user tyroneli -mtime -1 -exec chgrp groupid &#123;&#125; \;&#10;#&#22312;&#27599;&#22825;5&#28857;&#65292;&#22312;path&#30446;&#24405;&#19979;&#26597;&#25214;&#26368;&#21518;&#20462;&#25913;&#26102;&#38388;&#19968;&#22825;&#20043;&#20869;&#29992;&#25143;&#21517;&#20026;tyroneli&#30340;&#25991;&#20214;&#25110;&#30446;&#24405;&#65292;&#20462;&#25913;&#20854;&#25152;&#23646;&#32452;&#12290;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-_结语">3. <em>结语</em></h2><p>在日常操作中经常会接触到find命令，所以总结了以上几个我遇到过的应用场景作为备忘，也与诸君分享。find命令是最古老、最复杂的命令之一，本篇之外还有很多路要走。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-find命令简介">1.<em>find命令简介</em></h2><p>find命令主要用于文件搜索，它的功能非常强大，可以根据不同的标准搜索任何文件，可以在任何位置进行检索。find命令的主要格式如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find path test action</span><br></pre></td></tr></table></figure></p>
<p>（1）path表示要搜索的路径，可以同时指定多个路径，路径之间以空格隔开：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /user/bin              #&#25628;&#32034;/user/bin&#30446;&#24405;&#21644;&#23376;&#30446;&#24405;&#10;find /                      #&#25628;&#32034;&#26681;&#30446;&#24405;&#21450;&#23376;&#30446;&#24405;&#65288;&#23454;&#38469;&#19978;&#23601;&#26159;&#25628;&#32034;&#25972;&#20010;&#25991;&#20214;&#31995;&#32479;&#65289;&#10;find .                      #&#25628;&#32034;&#24403;&#21069;&#30446;&#24405;&#10;find -root                  #&#25628;&#32034;root&#29992;&#25143;&#30340;&#20027;&#30446;&#24405;&#10;find /user/bin /home        #&#25628;&#32034;/user/bin&#21644;/home&#30446;&#24405;&#21450;&#23427;&#20204;&#30340;&#23376;&#30446;&#24405;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://ningquec.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>